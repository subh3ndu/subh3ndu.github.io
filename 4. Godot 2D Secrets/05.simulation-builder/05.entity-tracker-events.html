<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>TmpzzHXqFkl2H</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <style type="text/css">:root {--c-caption: grey;--c-blue: #26bfe3;--c-green: #02e180;--c-orange: #f2971a;--c-pink: #e3266f;--c-bg: #fff;--c-bg-alt: #f5f5f5;--c-text-header: #fff;--c-text-body: #95989a;--padding: 20px;--padding-inv: calc(-1 * var(--padding));--fonts: "Open Sans", -apple-system, system-ui, "Segoe UI", "Roboto","Helvetica Neue", Arial, sans-serif;--font-size: 1.1rem;}html {font-size: 100%;}body {color: #444;font-family: var(--fonts);font-size: var(--font-size);line-height: 1.7;padding: 1em;margin: auto;max-width: 800px;background: #fefefe;}a {color: #0645ad;text-decoration: none;}a:visited {color: #0b0080;}a:hover {color: #06e;}a:active {color: #faa700;}a:focus {outline: thin dotted;}a::selection {background: rgba(255, 255, 0, 0.3);color: #0645ad;}*::selection {background: rgba(255, 255, 0, 0.3);color: #000;}p {margin: 1em 0;}.caption {text-align: center;color: var(--c-caption);font-style: italic;}.note,.tips,.warning {display: block;width: calc(100% - var(--padding) * 2);padding: 0 var(--padding);padding-bottom: var(--padding);background-color: var(--c-bg-alt);}.note:before,.tips:before,.warning:before {display: block;margin: 0 var(--padding-inv) 10px var(--padding-inv);padding-left: var(--padding);font-style: bold;color: white;}.note:before {content: "Note";background-color: var(--c-blue);}.tips:before {content: "Tips";background-color: var(--c-pink);}.warning:before {content: "Warning";background-color: var(--c-orange);}img {max-width: 100%;}h1,h2,h3,h4,h5,h6 {color: #111;line-height: 125%;margin-top: 2em;font-weight: normal;}h4,h5,h6 {font-weight: bold;}h1 {font-size: 2.5em;}h2 {font-size: 2em;}h3 {font-size: 1.5em;}h4 {font-size: 1.2em;}blockquote {color: #666666;margin: 0;padding-left: 3em;border-left: 0.5em #eee solid;}hr {display: block;height: 2px;border: 0;border-top: 1px solid #aaa;border-bottom: 1px solid #eee;margin: 1em 0;padding: 0;}pre,code,kbd,samp {color: #0084b8;font-family: monospace, monospace;}pre {background-color: #f9f9f9;padding: 1em;font-size: 14px;white-space: pre-wrap;word-wrap: break-word;}code {white-space: pre-wrap;}b,strong {font-weight: bold;}dfn {font-style: italic;color: var(--c-blue);}ins {background: #ff9;color: #000;text-decoration: none;}ul,ol {margin: 1em 0;padding: 0 0 0 2em;}li p:last-child {margin-bottom: 0;}ul ul,ol ol {margin: 0.3em 0;}dl {margin-bottom: 1em;}dt {font-weight: bold;margin-bottom: 0.8em;}dd {margin: 0 0 0.8em 2em;}dd:last-child {margin-bottom: 0;}img {border: 0;-ms-interpolation-mode: bicubic;vertical-align: middle;}figure {display: block;text-align: center;margin: 1em 0;}figure img {border: none;margin: 0 auto;}figcaption {font-size: 0.8em;font-style: italic;margin: 0 0 0.8em;}.author {font-size: 1.2em;text-align: center;}tag {min-width: 3.2em;text-align: center;border-radius: 8px;padding: 0 4px;margin-bottom: 0;margin-top: 4px;margin-right: 0.2em;display: inline-block;color: white;}tag.update {background: var(--c-blue);}tag.new {background: var(--c-green);}tag.update:after {content: "update";}tag.new:after {content: "new";}button {background-color: var(--c-blue);color: white;border: none;cursor: pointer;line-height: 2rem;font-size: 1.2rem;margin: 0.75rem 0;overflow: visible;padding: 0.75rem 1.5rem;border-radius: 1rem;transition: background-color $transition-duration;white-space: nowrap;}</style>
</head>
<body>
<h1 id="implementing-the-events-singleton-and-entitytracker">Implementing the Events singleton and EntityTracker</h1>
<p>We don’t want entities to be aware of each other. A Stirling engine should never hold a reference to another engine, battery, or wire.</p>
<p>Yet, we need a way for entities to work with each other. We also need to manage the game grid so the player can only put one entity per cell.</p>
<p>To do so, we’re going to code two tools:</p>
<ol type="1">
<li>A singleton that allows any node to emit and receive signals globally. We call this the <code>Events</code> bus pattern, and you can find a lesson dedicated to it in the design pattern chapter.</li>
<li>A helper object that will keep track of which grid cells are occupied by an entity, the <code>EntityTracker</code>.</li>
</ol>
<h2 id="the-events-bus-singleton">The Events bus singleton</h2>
<p>Entities are in a layer with the player, some in a layer beneath the player, and systems and the GUI will be in different branches of the scene tree. All these can be involved in the creation of an entity and need to work in concert. For example, in the final game, we want the player to be able to take an item in their inventory, select it, and place it or drop it in the world.</p>
<p>Connecting them all individually or bubbling every signal up the scene tree chain would be prohibitively messy and connect every entity.</p>
<p>Our goal, as programmers, is to limit connection and communication between objects to the minimum. We want every entity to be uniquely <strong>unaware</strong> of any of its neighbors. As a result, we will use a global object to emit events: an autoload.</p>
<p><em>To learn more about our recommended “best practices” regarding signals, see the Best Practices chapter.</em></p>
<p>We create an <code>Events.gd</code> script in the <code>Autoloads</code> folder that we add to the list of <em>Autoloads</em> in the <em>Project Settings… -&gt; Autoload</em> tab.</p>
<p>Every signal that may need to transcend the hierarchy can go here. We will add more in future lessons, but for now, we add two signals related to placing and removing entities.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>

<span style="color:#75715e">## Signal emitted when the player places an entity, passing the entity and its</span>
<span style="color:#75715e">## position in map coordinates</span>
<span style="color:#66d9ef">signal</span> entity_placed(entity, cellv)

<span style="color:#75715e">## Signal emitted when the player removes an entity, passing the entity and its</span>
<span style="color:#75715e">## position in map coordinates</span>
<span style="color:#66d9ef">signal</span> entity_removed(entity, cellv)
</pre>
<h2 id="the-entitytracker">The EntityTracker</h2>
<p>The <code>EntityTracker</code> is a helper object that belongs to the <code>Simulation</code>. Its purpose is to help the <code>EntityPlacer</code> figure out if an entity already occupies the current cell and is the one who emits signals when the player places or removes entities.</p>
<p>Create a new script in the <em>FileSystem</em> dock and have it inherit from <code>Reference</code>. References are lighter than <code>Node</code>s and get erased by Godot when they are no longer referred to by anyone. That makes them ideal for little helpers like this.</p>
<p>The class provides methods to register, remove, and get a reference to an entity in the game grid. A fourth function allows us to check if a cell already has an entity in it.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e">## Sub-class of the simulation that keeps track of all entities and their location</span>
<span style="color:#75715e">## using dictionary keys. Emits signals when the player places or removes entities.</span>
class_name EntityTracker
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Reference</span>

<span style="color:#75715e">## A Dictionary of entities, keyed using `Vector2` tilemap coordinates.</span>
<span style="color:#66d9ef">var</span> entities :<span style="color:#f92672">=</span> {}

<span style="color:#75715e">## Adds an entity to the dictionary so we can prevent other entities from taking</span>
<span style="color:#75715e">## the same location.</span>
<span style="color:#66d9ef">func</span> place_entity(entity, cellv: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#75715e"># If the cell is already taken, refuse to add it again.</span>
    <span style="color:#66d9ef">if</span> entities<span style="color:#f92672">.</span>has(cellv):
        <span style="color:#66d9ef">return</span>

    <span style="color:#75715e"># Add the entity keyed by its coordinates on the map.</span>
    entities[cellv] <span style="color:#f92672">=</span> entity
    <span style="color:#75715e"># Emit the signal about the new entity.</span>
    Events<span style="color:#f92672">.</span>emit_signal(<span style="color:#e6db74">&quot;entity_placed&quot;</span>, entity, cellv)


<span style="color:#75715e">## Removes an entity from the dictionary so other entities can take its place</span>
<span style="color:#75715e">## in its location on the map.</span>
<span style="color:#66d9ef">func</span> remove_entity(cellv: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#75715e"># Refuse to function if the entity does not exist.</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> entities<span style="color:#f92672">.</span>has(cellv):
        <span style="color:#66d9ef">return</span>

    <span style="color:#75715e"># Get the entity, queue it for deletion, and emit a signal about</span>
    <span style="color:#75715e"># its removal.</span>
    <span style="color:#66d9ef">var</span> entity <span style="color:#f92672">=</span> entities[cellv]
    <span style="color:#66d9ef">var</span> _result :<span style="color:#f92672">=</span> entities<span style="color:#f92672">.</span>erase(cellv)
    Events<span style="color:#f92672">.</span>emit_signal(<span style="color:#e6db74">&quot;entity_removed&quot;</span>, entity, cellv)
    entity<span style="color:#f92672">.</span>queue_free()


<span style="color:#75715e">## Returns true if there is an entity at the given location.</span>
<span style="color:#66d9ef">func</span> is_cell_occupied(cellv: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
    <span style="color:#66d9ef">return</span> entities<span style="color:#f92672">.</span>has(cellv)


<span style="color:#75715e">## Returns the entity at the given location, if it exists, or null otherwise.</span>
<span style="color:#66d9ef">func</span> get_entity_at(cellv: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Node2D</span>:
    <span style="color:#66d9ef">if</span> entities<span style="color:#f92672">.</span>has(cellv):
        <span style="color:#66d9ef">return</span> entities[cellv]
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> null
</pre>
<h2 id="simulation-and-delegation">Simulation and delegation</h2>
<p>The <code>Simulation</code> class itself will not do much processing. Instead, we want it to delegate its duties to other classes and systems.</p>
<p>In the <code>Simulation.gd</code> script, we create an instance of our new <code>EntityTracker</code> class. We’ll pass it to the <code>EntityPlacer</code> in the next lesson so it can inform it of new entities.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># ...</span>
<span style="color:#75715e"># const INVISIBLE_BARRIER_ID := 2</span>

<span style="color:#66d9ef">var</span> _tracker :<span style="color:#f92672">=</span> EntityTracker<span style="color:#f92672">.</span>new()

<span style="color:#75715e"># onready var _ground := $GameWorld/GroundTiles</span>
<span style="color:#75715e"># ...</span>
</pre>
<h2 id="code-reference">Code reference</h2>
<p>Here are complete scripts after adding changes in this lesson.</p>
<p>First, <code>Events.gd</code>.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>

<span style="color:#66d9ef">signal</span> entity_placed(entity, cellv)
<span style="color:#66d9ef">signal</span> entity_removed(entity, cellv)
</pre>
<p>Second, <code>EntityTracker.gd</code>.</p>
<pre style="color:#f8f8f2;background-color:#272822">class_name EntityTracker
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Reference</span>

<span style="color:#66d9ef">var</span> entities :<span style="color:#f92672">=</span> {}

<span style="color:#66d9ef">func</span> place_entity(entity, cellv: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">if</span> entities<span style="color:#f92672">.</span>has(cellv):
        <span style="color:#66d9ef">return</span>

    entities[cellv] <span style="color:#f92672">=</span> entity
    Events<span style="color:#f92672">.</span>emit_signal(<span style="color:#e6db74">&quot;entity_placed&quot;</span>, entity, cellv)


<span style="color:#66d9ef">func</span> remove_entity(cellv: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> entities<span style="color:#f92672">.</span>has(cellv):
        <span style="color:#66d9ef">return</span>

    <span style="color:#66d9ef">var</span> entity <span style="color:#f92672">=</span> entities[cellv]
    <span style="color:#66d9ef">var</span> _result :<span style="color:#f92672">=</span> entities<span style="color:#f92672">.</span>erase(cellv)
    Events<span style="color:#f92672">.</span>emit_signal(<span style="color:#e6db74">&quot;entity_removed&quot;</span>, entity, cellv)
    entity<span style="color:#f92672">.</span>queue_free()


<span style="color:#66d9ef">func</span> is_cell_occupied(cellv: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
    <span style="color:#66d9ef">return</span> entities<span style="color:#f92672">.</span>has(cellv)


<span style="color:#66d9ef">func</span> get_entity_at(cellv: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Node2D</span>:
    <span style="color:#66d9ef">if</span> entities<span style="color:#f92672">.</span>has(cellv):
        <span style="color:#66d9ef">return</span> entities[cellv]
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">return</span> null
</pre>
<p>Finally, <code>Simulation.gd</code>.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node</span>

<span style="color:#66d9ef">const</span> BARRIER_ID :<span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">const</span> INVISIBLE_BARRIER_ID :<span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>

<span style="color:#66d9ef">var</span> _tracker :<span style="color:#f92672">=</span> EntityTracker<span style="color:#f92672">.</span>new()

<span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> _ground :<span style="color:#f92672">=</span> <span style="color:#f92672">$</span>GameWorld<span style="color:#f92672">/</span>GroundTiles


<span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">var</span> barriers: <span style="color:#a6e22e">Array</span> <span style="color:#f92672">=</span> _ground<span style="color:#f92672">.</span>get_used_cells_by_id(BARRIER_ID)

    <span style="color:#66d9ef">for</span> cellv <span style="color:#f92672">in</span> barriers:
        _ground<span style="color:#f92672">.</span>set_cellv(cellv, INVISIBLE_BARRIER_ID)
</pre>
</body>
</html>
