<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Tmpl9AurcMlT0</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <style type="text/css">:root {--c-caption: grey;--c-blue: #26bfe3;--c-green: #02e180;--c-orange: #f2971a;--c-pink: #e3266f;--c-bg: #fff;--c-bg-alt: #f5f5f5;--c-text-header: #fff;--c-text-body: #95989a;--padding: 20px;--padding-inv: calc(-1 * var(--padding));--fonts: "Open Sans", -apple-system, system-ui, "Segoe UI", "Roboto","Helvetica Neue", Arial, sans-serif;--font-size: 1.1rem;}html {font-size: 100%;}body {color: #444;font-family: var(--fonts);font-size: var(--font-size);line-height: 1.7;padding: 1em;margin: auto;max-width: 800px;background: #fefefe;}a {color: #0645ad;text-decoration: none;}a:visited {color: #0b0080;}a:hover {color: #06e;}a:active {color: #faa700;}a:focus {outline: thin dotted;}a::selection {background: rgba(255, 255, 0, 0.3);color: #0645ad;}*::selection {background: rgba(255, 255, 0, 0.3);color: #000;}p {margin: 1em 0;}.caption {text-align: center;color: var(--c-caption);font-style: italic;}.note,.tips,.warning {display: block;width: calc(100% - var(--padding) * 2);padding: 0 var(--padding);padding-bottom: var(--padding);background-color: var(--c-bg-alt);}.note:before,.tips:before,.warning:before {display: block;margin: 0 var(--padding-inv) 10px var(--padding-inv);padding-left: var(--padding);font-style: bold;color: white;}.note:before {content: "Note";background-color: var(--c-blue);}.tips:before {content: "Tips";background-color: var(--c-pink);}.warning:before {content: "Warning";background-color: var(--c-orange);}img {max-width: 100%;}h1,h2,h3,h4,h5,h6 {color: #111;line-height: 125%;margin-top: 2em;font-weight: normal;}h4,h5,h6 {font-weight: bold;}h1 {font-size: 2.5em;}h2 {font-size: 2em;}h3 {font-size: 1.5em;}h4 {font-size: 1.2em;}blockquote {color: #666666;margin: 0;padding-left: 3em;border-left: 0.5em #eee solid;}hr {display: block;height: 2px;border: 0;border-top: 1px solid #aaa;border-bottom: 1px solid #eee;margin: 1em 0;padding: 0;}pre,code,kbd,samp {color: #0084b8;font-family: monospace, monospace;}pre {background-color: #f9f9f9;padding: 1em;font-size: 14px;white-space: pre-wrap;word-wrap: break-word;}code {white-space: pre-wrap;}b,strong {font-weight: bold;}dfn {font-style: italic;color: var(--c-blue);}ins {background: #ff9;color: #000;text-decoration: none;}ul,ol {margin: 1em 0;padding: 0 0 0 2em;}li p:last-child {margin-bottom: 0;}ul ul,ol ol {margin: 0.3em 0;}dl {margin-bottom: 1em;}dt {font-weight: bold;margin-bottom: 0.8em;}dd {margin: 0 0 0.8em 2em;}dd:last-child {margin-bottom: 0;}img {border: 0;-ms-interpolation-mode: bicubic;vertical-align: middle;}figure {display: block;text-align: center;margin: 1em 0;}figure img {border: none;margin: 0 auto;}figcaption {font-size: 0.8em;font-style: italic;margin: 0 0 0.8em;}.author {font-size: 1.2em;text-align: center;}tag {min-width: 3.2em;text-align: center;border-radius: 8px;padding: 0 4px;margin-bottom: 0;margin-top: 4px;margin-right: 0.2em;display: inline-block;color: white;}tag.update {background: var(--c-blue);}tag.new {background: var(--c-green);}tag.update:after {content: "update";}tag.new:after {content: "new";}button {background-color: var(--c-blue);color: white;border: none;cursor: pointer;line-height: 2rem;font-size: 1.2rem;margin: 0.75rem 0;overflow: visible;padding: 0.75rem 1.5rem;border-radius: 1rem;transition: background-color $transition-duration;white-space: nowrap;}</style>
</head>
<body>
<h1 id="the-rivers-generator">The rivers generator</h1>
<p>Let’s add rivers to our world map.</p>
<p>We’ll generate them as an <code>ImageTexture</code> on the CPU.</p>
<p>Then, we’ll pass the data to the shader to apply post-processing to them. By doing so, we’ll get more natural turns and flow.</p>
<p>First, we are going to generate straight lines like in the image below.</p>
<p>As you can see, the rivers can have branches.</p>
<figure>
<img src="data:image/png;base64,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" alt />
</figure>
<p>Here, we’re not concerned with drawing the rivers from their geographical source.</p>
<p>In the lesson, you’ll see we talk about start and end points. It’s not about geography; instead, we’re always talking about where the lines start and end.</p>
<p>We’ll draw series of connected lines, all 3-pixels wide. We’ll control random parameters like length, direction, and the number of branches with a <code>RandomNumberGenerator</code>.</p>
<p>Also, we’ll draw the rivers from their mouths to the sources, as it’s easier to draw a single line from which we branch out than drawing branches first and making them connect.</p>
<p>What matters to us with procedural drawing is not that we try to simulate the real world. Instead, we want to get an appealing and believable result.</p>
<p>After applying post-processing steps in the shader, we will get a result like the one below.</p>
<figure>
<img src="data:image/png;base64,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" alt />
</figure>
<p>Let’s now dive into the river generator’s code.</p>
<p>First, just like in our previous lesson, create a new script called <code>RiverGenerator.gd</code> and replace the contents with:</p>
<pre style="color:#f8f8f2;background-color:#272822">class_name RiverGenerator


<span style="color:#66d9ef">const</span> OFFSETS :<span style="color:#f92672">=</span> [
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>ZERO,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>RIGHT,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>RIGHT <span style="color:#f92672">+</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>UP,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>UP,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>LEFT <span style="color:#f92672">+</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>UP,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>LEFT,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>LEFT <span style="color:#f92672">+</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>DOWN,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>DOWN,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>RIGHT <span style="color:#f92672">+</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>DOWN
]

<span style="color:#66d9ef">const</span> RIVERS_MAX_BRANCHES :<span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
<span style="color:#66d9ef">const</span> BRANCH_LENGTH :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.65</span>)
<span style="color:#66d9ef">const</span> BRANCH_ANGLE :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">45</span>)
</pre>
<p>Like <code>Utils.gd</code>, this script is a library class that we register with <code>class_name RiverGenerator</code>, giving us access to its members anywhere in the code.</p>
<p>At the top, we define a few useful constants:</p>
<ul>
<li><code>OFFSETS</code> is a list of coordinates that make a 3px x 3px rectangle. For each point on the river path, we will draw a <code>3 x 3</code> rectangle. This isn’t the most efficient way of doing it, but it’s one of the simplest ways to implement it.</li>
<li><code>RIVERS_MAX_BRANCHES</code> is the maximum allowed number of branching paths from the main river path.</li>
<li><code>BRANCH_LENGTH</code> and <code>BRANCH_ANGLE</code> are ranges for respectively the length of a river branch and its angle compared to the main river body.</li>
</ul>
<h2 id="generating-all-the-rivers-in-a-loop">Generating all the rivers in a loop</h2>
<p>Our first function includes a loop that generates all rivers with their branches. It is the only public method of the class, the entry point for the generator:</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># Returns rivers generated from a noise-based height map as an image texture.</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> generate_rivers(
    rng: RandomNumberGenerator, texture: <span style="color:#a6e22e">Texture</span>, rivers_count: <span style="color:#a6e22e">int</span>, rivers_level: <span style="color:#a6e22e">Vector2</span>
) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">ImageTexture</span>:
    <span style="color:#66d9ef">var</span> rivers :<span style="color:#f92672">=</span> _generate_rivers(rng, texture, rivers_count, rivers_level)
    <span style="color:#66d9ef">return</span> _generate_rivers_texture(rng, rivers, texture<span style="color:#f92672">.</span>get_width(), texture<span style="color:#f92672">.</span>get_height())
</pre>
<p>Its input parameters are:</p>
<ul>
<li><code>rng</code>: the <code>RandomNumberGenerator</code> that will be provided from the main script.</li>
<li><code>texture</code>: the <em>Height Map</em> texture.</li>
<li><code>rivers_count</code>: the maximum number of rivers.</li>
<li><code>rivers_level</code>: the threshold values below which the river starts (<code>rivers_level.x</code>) and above where it ends (<code>rivers_level.y</code>).</li>
</ul>
<p>This function calls upon <code>_generate_rivers()</code> and <code>_generate_rivers_texture()</code>. The first function generates the river information, an array data structure that holds the river’s start and end points. The latter function uses this information to generate the actual <code>ImageTexture</code>.</p>
<p>Next we look at <code>_generate_rivers()</code>:</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># Generate all rivers in the map as an array of pixel positions.</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_rivers(
    rng: RandomNumberGenerator, texture: <span style="color:#a6e22e">Texture</span>, rivers_count: <span style="color:#a6e22e">int</span>, rivers_level: <span style="color:#a6e22e">Vector2</span>
) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>:
</pre>
<p>We first define <code>available_start_positions</code> and <code>available_end_positions</code>. They’re arrays that hold 2D vectors with possible positions for our rivers’ start and end.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> []

<span style="color:#66d9ef">var</span> available_start_positions :<span style="color:#f92672">=</span> []
<span style="color:#66d9ef">var</span> available_end_positions :<span style="color:#f92672">=</span> []

</pre>
<p>We construct them in the following for loop, based on the input <code>texture</code>, which is the <em>Height Map</em> noise texture in this case. Instead of using the <code>OpenSimplexNoise</code> property of the texture, we use the pixel data to make this generator more generic. Our function isn’t limited to <code>NoiseTexture</code> input data, but any texture supported by Godot. We define this parameter with the more generic <code>Texture</code> hint instead of <code>NoiseTexture</code>.</p>
<p>For <code>available_start_positions</code> we check if the noise value is less than <code>rivers_level.x</code> and likewise for <code>available_end_positions</code>, we check if <code>noise</code> is greater than <code>rivers_level.y</code>. This is the simple way we pick start and end positions for the river data, based on the input texture and the threshold interval <code>rivers_level</code>.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">var</span> image :<span style="color:#f92672">=</span> texture<span style="color:#f92672">.</span>get_data()
image<span style="color:#f92672">.</span>lock()
<span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(texture<span style="color:#f92672">.</span>get_width()):
    <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(texture<span style="color:#f92672">.</span>get_height()):
        <span style="color:#66d9ef">var</span> noise :<span style="color:#f92672">=</span> image<span style="color:#f92672">.</span>get_pixel(x, y)<span style="color:#f92672">.</span>r

        <span style="color:#66d9ef">if</span> noise <span style="color:#f92672">&lt;</span> rivers_level<span style="color:#f92672">.</span>x:
            available_start_positions<span style="color:#f92672">.</span>push_back(<span style="color:#a6e22e">Vector2</span>(x, y))
        <span style="color:#66d9ef">elif</span> rivers_level<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;</span> noise:
            available_end_positions<span style="color:#f92672">.</span>push_back(<span style="color:#a6e22e">Vector2</span>(x, y))
image<span style="color:#f92672">.</span>unlock()
</pre>
<p class="note">
We’re using <code>Image.lock()</code> and <code>Image.unlock()</code> when accessing image data. Locking is currently required for both read and write operations in Godot 3.2. There’s an <a href="https://github.com/godotengine/godot/issues/13934">open issue on this topic</a> because locking and unlocking image data should be, in theory, required only for write operations.
</p>
<p>Finally, in the last for loop, we generate the individual river parts by calling <code>_generate_river()</code>. That function uses the available start and end positions as well as the <code>RandomNumberGenerator</code>.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">for</span> _i <span style="color:#f92672">in</span> range(rivers_count):
    <span style="color:#66d9ef">var</span> river :<span style="color:#f92672">=</span> _generate_river(rng, available_start_positions, available_end_positions)
    <span style="color:#66d9ef">if</span> river<span style="color:#f92672">.</span>empty():
        <span style="color:#66d9ef">break</span>
    out <span style="color:#f92672">+=</span> river

<span style="color:#66d9ef">return</span> out
</pre>
<p>Here is the full code for <code>_generate_rivers()</code>:</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># Generate all rivers in the map as an array of pixel positions.</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_rivers(
    rng: RandomNumberGenerator, texture: <span style="color:#a6e22e">Texture</span>, rivers_count: <span style="color:#a6e22e">int</span>, rivers_level: <span style="color:#a6e22e">Vector2</span>
) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>:
    <span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> []

    <span style="color:#66d9ef">var</span> available_start_positions :<span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">var</span> available_end_positions :<span style="color:#f92672">=</span> []

    <span style="color:#66d9ef">var</span> image :<span style="color:#f92672">=</span> texture<span style="color:#f92672">.</span>get_data()
    image<span style="color:#f92672">.</span>lock()
    <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(texture<span style="color:#f92672">.</span>get_width()):
        <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(texture<span style="color:#f92672">.</span>get_height()):
            <span style="color:#66d9ef">var</span> noise :<span style="color:#f92672">=</span> image<span style="color:#f92672">.</span>get_pixel(x, y)<span style="color:#f92672">.</span>r
            <span style="color:#66d9ef">if</span> noise <span style="color:#f92672">&lt;</span> rivers_level<span style="color:#f92672">.</span>x:
                available_start_positions<span style="color:#f92672">.</span>push_back(<span style="color:#a6e22e">Vector2</span>(x, y))
            <span style="color:#66d9ef">elif</span> rivers_level<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;</span> noise:
                available_end_positions<span style="color:#f92672">.</span>push_back(<span style="color:#a6e22e">Vector2</span>(x, y))
    image<span style="color:#f92672">.</span>unlock()

    <span style="color:#66d9ef">for</span> _i <span style="color:#f92672">in</span> range(rivers_count):
        <span style="color:#66d9ef">var</span> river :<span style="color:#f92672">=</span> _generate_river(rng, available_start_positions, available_end_positions)
        <span style="color:#66d9ef">if</span> river<span style="color:#f92672">.</span>empty():
            <span style="color:#66d9ef">break</span>
        out <span style="color:#f92672">+=</span> river

    <span style="color:#66d9ef">return</span> out
</pre>
<h2 id="generating-main-river-segments">Generating main river segments</h2>
<p>Up next, we have <code>_generate_river()</code>, our function to generate individual river segments.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_river(
    rng: RandomNumberGenerator, available_start_positions: <span style="color:#a6e22e">Array</span>, available_end_positions: <span style="color:#a6e22e">Array</span>
) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>:
</pre>
<p>We first check for available starting positions, and if we have none, we return with an empty array.</p>
<p>This is why we had a condition in the last <code>for</code> loop of <code>_generate_rivers()</code>. We mutate <code>available_start_positions</code> inside of <code>_generate_river()</code> by removing positions as we use them. Doing so ensures sure that we don’t pick the same start position twice.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> []
<span style="color:#66d9ef">if</span> available_start_positions<span style="color:#f92672">.</span>empty():
    <span style="color:#66d9ef">return</span> out
</pre>
<p>We pick a random start position by generating a random index with <code>RandomNumberGenerator</code>. We store this value in the <code>start</code> variable and remove it from <code>available_start_positions</code>.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">var</span> r :<span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>randi_range(<span style="color:#ae81ff">0</span>, available_start_positions<span style="color:#f92672">.</span>size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
<span style="color:#66d9ef">var</span> start: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> available_start_positions[r]
available_start_positions<span style="color:#f92672">.</span>remove(r)
</pre>
<p>We then try to find the <code>end</code> position for the river by finding the minimum distance to all vectors from <code>available_end_positions</code>. Unlike before, we don’t remove these positions as they are reusable.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">var</span> end :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>ZERO
<span style="color:#66d9ef">var</span> min_distance :<span style="color:#f92672">=</span> INF

<span style="color:#66d9ef">for</span> position <span style="color:#f92672">in</span> available_end_positions:
    <span style="color:#66d9ef">var</span> distance: <span style="color:#a6e22e">float</span> <span style="color:#f92672">=</span> (position <span style="color:#f92672">-</span> start)<span style="color:#f92672">.</span>length()
    <span style="color:#66d9ef">if</span> min_distance <span style="color:#f92672">&gt;</span> distance:
        min_distance <span style="color:#f92672">=</span> distance
        end <span style="color:#f92672">=</span> position

</pre>
<p>Once we found <code>end</code>, we append the <code>[start, end]</code> array to <code>out</code>. Before returning it from the function, we append additional data from <code>_generate_river_branches()</code>, the one we’re going to write next.</p>
<pre style="color:#f8f8f2;background-color:#272822">out<span style="color:#f92672">.</span>push_back([start, end])
out <span style="color:#f92672">+=</span> _generate_river_branches(rng, start, end)

<span style="color:#66d9ef">return</span> out
</pre>
<p>Here is the complete code for <code>_generate_river()</code>:</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_river(
    rng: RandomNumberGenerator, available_start_positions: <span style="color:#a6e22e">Array</span>, available_end_positions: <span style="color:#a6e22e">Array</span>
) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>:
    <span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">if</span> available_start_positions<span style="color:#f92672">.</span>empty():
        <span style="color:#66d9ef">return</span> out

    <span style="color:#66d9ef">var</span> r :<span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>randi_range(<span style="color:#ae81ff">0</span>, available_start_positions<span style="color:#f92672">.</span>size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">var</span> start: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> available_start_positions[r]
    available_start_positions<span style="color:#f92672">.</span>remove(r)

    <span style="color:#66d9ef">var</span> end :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>ZERO
    <span style="color:#66d9ef">var</span> min_distance :<span style="color:#f92672">=</span> INF
    <span style="color:#66d9ef">for</span> position <span style="color:#f92672">in</span> available_end_positions:
        <span style="color:#66d9ef">var</span> distance: <span style="color:#a6e22e">float</span> <span style="color:#f92672">=</span> (position <span style="color:#f92672">-</span> start)<span style="color:#f92672">.</span>length()
        <span style="color:#66d9ef">if</span> min_distance <span style="color:#f92672">&gt;</span> distance:
            min_distance <span style="color:#f92672">=</span> distance
            end <span style="color:#f92672">=</span> position

    out<span style="color:#f92672">.</span>push_back([start, end])
    out <span style="color:#f92672">+=</span> _generate_river_branches(rng, start, end)

    <span style="color:#66d9ef">return</span> out
</pre>
<h2 id="generating-river-branches">Generating river branches</h2>
<p>Our rivers can branch out. This is what <code>_generate_river_branches()</code> controls.</p>
<p>Before generating the branches, we store the vector representing the main path of the river as <code>river_vector</code>.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_river_branches(rng: RandomNumberGenerator, start: <span style="color:#a6e22e">Vector2</span>, end: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>:
    <span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">var</span> river_vector :<span style="color:#f92672">=</span> end <span style="color:#f92672">-</span> start
</pre>
<p>We then loop over a random number of branches between <code>0</code> and <code>RIVERS_MAX_BRANCHES</code>. If the value generated by the <code>RandomNumberGenerator</code> is <code>0</code>, no branches are created.</p>
<p>In the loop, we generate a random angle and store it in <code>branch_angle</code>. Next, by a toss of a coin (50% chance), we mirror this value: <code>branch_angle *= -1</code> so we don’t always get river branches on the same side.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">for</span> _j <span style="color:#f92672">in</span> range(rng<span style="color:#f92672">.</span>randi_range(<span style="color:#ae81ff">0</span>, RIVERS_MAX_BRANCHES)):
    <span style="color:#66d9ef">var</span> branch_angle :<span style="color:#f92672">=</span> deg2rad(rng<span style="color:#f92672">.</span>randf_range(BRANCH_ANGLE<span style="color:#f92672">.</span>x, BRANCH_ANGLE<span style="color:#f92672">.</span>y))
    <span style="color:#66d9ef">if</span> rng<span style="color:#f92672">.</span>randf() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.5</span>:
        branch_angle <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</pre>
<p>Still in the loop, we generate a randomized <code>branch_length</code> using <code>RandomNumberGenerator</code>. For the starting position, we pick a place on the main river path using <code>Vector2.linear_interpolate()</code> and <code>rng.randf()</code>. As for the branch’s end position, we calculate it using all the above variables.</p>
<pre style="color:#f8f8f2;background-color:#272822">    <span style="color:#66d9ef">var</span> branch_length :<span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>randf_range(BRANCH_LENGTH<span style="color:#f92672">.</span>x, BRANCH_LENGTH<span style="color:#f92672">.</span>y)
    <span style="color:#66d9ef">var</span> branch_start :<span style="color:#f92672">=</span> start<span style="color:#f92672">.</span>linear_interpolate(end, rng<span style="color:#f92672">.</span>randf())
    <span style="color:#66d9ef">var</span> branch_end :<span style="color:#f92672">=</span> (branch_start <span style="color:#f92672">+</span> branch_length <span style="color:#f92672">*</span> river_vector<span style="color:#f92672">.</span>rotated(branch_angle))
    out<span style="color:#f92672">.</span>push_back([branch_start, branch_end])
</pre>
<p>And we finally return the <code>out</code> value, an array of branch start and ends:</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">return</span> out
</pre>
<p>Here is the complete function:</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_river_branches(rng: RandomNumberGenerator, start: <span style="color:#a6e22e">Vector2</span>, end: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>:
    <span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> []

    <span style="color:#66d9ef">var</span> river_vector :<span style="color:#f92672">=</span> end <span style="color:#f92672">-</span> start
    <span style="color:#66d9ef">for</span> _j <span style="color:#f92672">in</span> range(rng<span style="color:#f92672">.</span>randi_range(<span style="color:#ae81ff">0</span>, RIVERS_MAX_BRANCHES)):
        <span style="color:#66d9ef">var</span> branch_angle :<span style="color:#f92672">=</span> deg2rad(rng<span style="color:#f92672">.</span>randf_range(BRANCH_ANGLE<span style="color:#f92672">.</span>x, BRANCH_ANGLE<span style="color:#f92672">.</span>y))
        <span style="color:#66d9ef">if</span> rng<span style="color:#f92672">.</span>randf() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.5</span>:
            branch_angle <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">var</span> branch_length :<span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>randf_range(BRANCH_LENGTH<span style="color:#f92672">.</span>x, BRANCH_LENGTH<span style="color:#f92672">.</span>y)
        <span style="color:#66d9ef">var</span> branch_start :<span style="color:#f92672">=</span> start<span style="color:#f92672">.</span>linear_interpolate(end, rng<span style="color:#f92672">.</span>randf())
        <span style="color:#66d9ef">var</span> branch_end :<span style="color:#f92672">=</span> (branch_start <span style="color:#f92672">+</span> branch_length <span style="color:#f92672">*</span> river_vector<span style="color:#f92672">.</span>rotated(branch_angle))
        out<span style="color:#f92672">.</span>push_back([branch_start, branch_end])

    <span style="color:#66d9ef">return</span> out
</pre>
<h2 id="converting-the-rivers-data-to-a-texture">Converting the river’s data to a texture</h2>
<p>Our last step is to generate the <code>ImageTexture</code>, which we do in <code>_generate_rivers_texture()</code>:</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># Converts generated rivers array as an image texture.</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_rivers_texture(
    rng: RandomNumberGenerator, rivers: <span style="color:#a6e22e">Array</span>, width: <span style="color:#a6e22e">float</span>, height: <span style="color:#a6e22e">float</span>
) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">ImageTexture</span>:
</pre>
<p>We start by creating an empty <code>image</code> with the same size as the input texture. We make sure it’s <code>Image.FORMAT_RF</code> so we store information only on the red channel, as floats.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">var</span> image :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Image</span><span style="color:#f92672">.</span>new()
image<span style="color:#f92672">.</span>create(width, height, true, <span style="color:#a6e22e">Image</span><span style="color:#f92672">.</span>FORMAT_RF)
</pre>
<p>In the for loop, we store the length of the river in <code>distance</code> and create a <code>step</code> value based on it so we can traverse the path step-by-step. At this point, branches are stored in the same way as rivers are so we apply the same method.</p>
<pre style="color:#f8f8f2;background-color:#272822">image<span style="color:#f92672">.</span>lock()
<span style="color:#66d9ef">for</span> river <span style="color:#f92672">in</span> rivers:
    <span style="color:#66d9ef">var</span> distance: <span style="color:#a6e22e">float</span> <span style="color:#f92672">=</span> (river[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> river[<span style="color:#ae81ff">0</span>])<span style="color:#f92672">.</span>length()
    <span style="color:#66d9ef">var</span> step :<span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> distance
    <span style="color:#66d9ef">var</span> t :<span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>
</pre>
<p>An inner while loop traverses the river path. For each incremental step, we assign <code>Color(1, 0, 0, 0)</code> to that pixel position and all pixels around it in a <code>3 x 3</code> square.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">for</span> river <span style="color:#f92672">in</span> rivers:
    <span style="color:#75715e"># ...</span>
    <span style="color:#66d9ef">while</span> t <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>:
        <span style="color:#66d9ef">for</span> offset <span style="color:#f92672">in</span> OFFSETS:
            <span style="color:#66d9ef">var</span> position: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> river[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>linear_interpolate(river[<span style="color:#ae81ff">1</span>], t) <span style="color:#f92672">+</span> offset
            <span style="color:#66d9ef">if</span> position<span style="color:#f92672">.</span>x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> width <span style="color:#f92672">&lt;=</span> position<span style="color:#f92672">.</span>x <span style="color:#f92672">or</span> position<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> height <span style="color:#f92672">&lt;=</span> position<span style="color:#f92672">.</span>y:
                <span style="color:#66d9ef">continue</span>

            image<span style="color:#f92672">.</span>set_pixelv(position, <span style="color:#a6e22e">Color</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>))
        t <span style="color:#f92672">+=</span> step
image<span style="color:#f92672">.</span>unlock()
</pre>
<p>After the loop terminates, we make sure to generate mipmaps with <code>Image.generate_mipmaps()</code>. This is required to use <code>textureLod()</code> in the shader, which samples data from a lower quality, blurred image. We are going to use this function to accumulate moisture around rivers.</p>
<pre style="color:#f8f8f2;background-color:#272822">image<span style="color:#f92672">.</span>generate_mipmaps()
</pre>
<p>We finally create a new <code>ImageTexture</code> using the <code>Image</code> data we constructed and return the result.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> <span style="color:#a6e22e">ImageTexture</span><span style="color:#f92672">.</span>new()
out<span style="color:#f92672">.</span>create_from_image(image)
<span style="color:#66d9ef">return</span> out
</pre>
<p>Here is the complete function:</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># Converts generated rivers array as an image texture.</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_rivers_texture(
    rng: RandomNumberGenerator, rivers: <span style="color:#a6e22e">Array</span>, width: <span style="color:#a6e22e">float</span>, height: <span style="color:#a6e22e">float</span>
) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">ImageTexture</span>:
    <span style="color:#66d9ef">var</span> image :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Image</span><span style="color:#f92672">.</span>new()
    image<span style="color:#f92672">.</span>create(width, height, true, <span style="color:#a6e22e">Image</span><span style="color:#f92672">.</span>FORMAT_RF)

    image<span style="color:#f92672">.</span>lock()
    <span style="color:#66d9ef">for</span> river <span style="color:#f92672">in</span> rivers:
        <span style="color:#66d9ef">var</span> distance: <span style="color:#a6e22e">float</span> <span style="color:#f92672">=</span> (river[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> river[<span style="color:#ae81ff">0</span>])<span style="color:#f92672">.</span>length()
        <span style="color:#66d9ef">var</span> step :<span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> distance
        <span style="color:#66d9ef">var</span> t :<span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>
        <span style="color:#66d9ef">while</span> t <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">for</span> offset <span style="color:#f92672">in</span> OFFSETS:
                <span style="color:#66d9ef">var</span> position: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> river[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>linear_interpolate(river[<span style="color:#ae81ff">1</span>], t) <span style="color:#f92672">+</span> offset
                <span style="color:#66d9ef">if</span> position<span style="color:#f92672">.</span>x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> width <span style="color:#f92672">&lt;=</span> position<span style="color:#f92672">.</span>x <span style="color:#f92672">or</span> position<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> height <span style="color:#f92672">&lt;=</span> position<span style="color:#f92672">.</span>y:
                    <span style="color:#66d9ef">continue</span>

                image<span style="color:#f92672">.</span>set_pixelv(position, <span style="color:#a6e22e">Color</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>))
            t <span style="color:#f92672">+=</span> step
    image<span style="color:#f92672">.</span>unlock()
    image<span style="color:#f92672">.</span>generate_mipmaps()

    <span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> <span style="color:#a6e22e">ImageTexture</span><span style="color:#f92672">.</span>new()
    out<span style="color:#f92672">.</span>create_from_image(image)
    <span style="color:#66d9ef">return</span> out
</pre>
<p>This concludes the lesson on generating rivers. In the next part, we’ll put everything together on the CPU side.</p>
<h2 id="references">References</h2>
<p>The following code listing shows the full <em>RiverGenerator.gd</em> code in one place.</p>
<pre style="color:#f8f8f2;background-color:#272822">class_name RiverGenerator


<span style="color:#66d9ef">const</span> OFFSETS :<span style="color:#f92672">=</span> [
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>ZERO,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>RIGHT,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>RIGHT <span style="color:#f92672">+</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>UP,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>UP,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>LEFT <span style="color:#f92672">+</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>UP,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>LEFT,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>LEFT <span style="color:#f92672">+</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>DOWN,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>DOWN,
    <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>RIGHT <span style="color:#f92672">+</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>DOWN
]

<span style="color:#66d9ef">const</span> RIVERS_MAX_BRANCHES :<span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
<span style="color:#66d9ef">const</span> BRANCH_LENGTH :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(<span style="color:#ae81ff">0.3</span>, <span style="color:#ae81ff">0.65</span>)
<span style="color:#66d9ef">const</span> BRANCH_ANGLE :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(<span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">45</span>)


<span style="color:#75715e"># Returns rivers generated from a noise-based height map as an image texture.</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> generate_rivers(
    rng: RandomNumberGenerator, texture: <span style="color:#a6e22e">Texture</span>, rivers_count: <span style="color:#a6e22e">int</span>, rivers_level: <span style="color:#a6e22e">Vector2</span>
) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">ImageTexture</span>:
    <span style="color:#66d9ef">var</span> rivers :<span style="color:#f92672">=</span> _generate_rivers(rng, texture, rivers_count, rivers_level)
    <span style="color:#66d9ef">return</span> _generate_rivers_texture(rng, rivers, texture<span style="color:#f92672">.</span>get_width(), texture<span style="color:#f92672">.</span>get_height())


<span style="color:#75715e"># Generate all rivers in the map as an array of pixel positions.</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_rivers(
    rng: RandomNumberGenerator, texture: <span style="color:#a6e22e">Texture</span>, rivers_count: <span style="color:#a6e22e">int</span>, rivers_level: <span style="color:#a6e22e">Vector2</span>
) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>:
    <span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> []

    <span style="color:#66d9ef">var</span> available_start_positions :<span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">var</span> available_end_positions :<span style="color:#f92672">=</span> []

    <span style="color:#66d9ef">var</span> image :<span style="color:#f92672">=</span> texture<span style="color:#f92672">.</span>get_data()
    image<span style="color:#f92672">.</span>lock()
    <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(texture<span style="color:#f92672">.</span>get_width()):
        <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(texture<span style="color:#f92672">.</span>get_height()):
            <span style="color:#66d9ef">var</span> noise :<span style="color:#f92672">=</span> image<span style="color:#f92672">.</span>get_pixel(x, y)<span style="color:#f92672">.</span>r
            <span style="color:#66d9ef">if</span> noise <span style="color:#f92672">&lt;</span> rivers_level<span style="color:#f92672">.</span>x:
                available_start_positions<span style="color:#f92672">.</span>push_back(<span style="color:#a6e22e">Vector2</span>(x, y))
            <span style="color:#66d9ef">elif</span> rivers_level<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;</span> noise:
                available_end_positions<span style="color:#f92672">.</span>push_back(<span style="color:#a6e22e">Vector2</span>(x, y))
    image<span style="color:#f92672">.</span>unlock()

    <span style="color:#66d9ef">for</span> _i <span style="color:#f92672">in</span> range(rivers_count):
        <span style="color:#66d9ef">var</span> river :<span style="color:#f92672">=</span> _generate_river(rng, available_start_positions, available_end_positions)
        <span style="color:#66d9ef">if</span> river<span style="color:#f92672">.</span>empty():
            <span style="color:#66d9ef">break</span>
        out <span style="color:#f92672">+=</span> river

    <span style="color:#66d9ef">return</span> out


<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_river(
    rng: RandomNumberGenerator, available_start_positions: <span style="color:#a6e22e">Array</span>, available_end_positions: <span style="color:#a6e22e">Array</span>
) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>:
    <span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">if</span> available_start_positions<span style="color:#f92672">.</span>empty():
        <span style="color:#66d9ef">return</span> out

    <span style="color:#66d9ef">var</span> r :<span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>randi_range(<span style="color:#ae81ff">0</span>, available_start_positions<span style="color:#f92672">.</span>size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">var</span> start: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> available_start_positions[r]
    available_start_positions<span style="color:#f92672">.</span>remove(r)

    <span style="color:#66d9ef">var</span> end :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>ZERO
    <span style="color:#66d9ef">var</span> min_distance :<span style="color:#f92672">=</span> INF
    <span style="color:#66d9ef">for</span> position <span style="color:#f92672">in</span> available_end_positions:
        <span style="color:#66d9ef">var</span> distance: <span style="color:#a6e22e">float</span> <span style="color:#f92672">=</span> (position <span style="color:#f92672">-</span> start)<span style="color:#f92672">.</span>length()
        <span style="color:#66d9ef">if</span> min_distance <span style="color:#f92672">&gt;</span> distance:
            min_distance <span style="color:#f92672">=</span> distance
            end <span style="color:#f92672">=</span> position

    out<span style="color:#f92672">.</span>push_back([start, end])
    out <span style="color:#f92672">+=</span> _generate_river_branches(rng, start, end)

    <span style="color:#66d9ef">return</span> out


<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_river_branches(rng: RandomNumberGenerator, start: <span style="color:#a6e22e">Vector2</span>, end: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Array</span>:
    <span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> []

    <span style="color:#66d9ef">var</span> river_vector :<span style="color:#f92672">=</span> end <span style="color:#f92672">-</span> start
    <span style="color:#66d9ef">for</span> _j <span style="color:#f92672">in</span> range(rng<span style="color:#f92672">.</span>randi_range(<span style="color:#ae81ff">0</span>, RIVERS_MAX_BRANCHES)):
        <span style="color:#66d9ef">var</span> branch_angle :<span style="color:#f92672">=</span> deg2rad(rng<span style="color:#f92672">.</span>randf_range(BRANCH_ANGLE<span style="color:#f92672">.</span>x, BRANCH_ANGLE<span style="color:#f92672">.</span>y))
        <span style="color:#66d9ef">if</span> rng<span style="color:#f92672">.</span>randf() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.5</span>:
            branch_angle <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">var</span> branch_length :<span style="color:#f92672">=</span> rng<span style="color:#f92672">.</span>randf_range(BRANCH_LENGTH<span style="color:#f92672">.</span>x, BRANCH_LENGTH<span style="color:#f92672">.</span>y)
        <span style="color:#66d9ef">var</span> branch_start :<span style="color:#f92672">=</span> start<span style="color:#f92672">.</span>linear_interpolate(end, rng<span style="color:#f92672">.</span>randf())
        <span style="color:#66d9ef">var</span> branch_end :<span style="color:#f92672">=</span> (branch_start <span style="color:#f92672">+</span> branch_length <span style="color:#f92672">*</span> river_vector<span style="color:#f92672">.</span>rotated(branch_angle))
        out<span style="color:#f92672">.</span>push_back([branch_start, branch_end])

    <span style="color:#66d9ef">return</span> out


<span style="color:#75715e"># Converts generated rivers array as an image texture.</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">func</span> _generate_rivers_texture(
    rng: RandomNumberGenerator, rivers: <span style="color:#a6e22e">Array</span>, width: <span style="color:#a6e22e">float</span>, height: <span style="color:#a6e22e">float</span>
) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">ImageTexture</span>:
    <span style="color:#66d9ef">var</span> image :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Image</span><span style="color:#f92672">.</span>new()
    image<span style="color:#f92672">.</span>create(width, height, true, <span style="color:#a6e22e">Image</span><span style="color:#f92672">.</span>FORMAT_RF)

    image<span style="color:#f92672">.</span>lock()
    <span style="color:#66d9ef">for</span> river <span style="color:#f92672">in</span> rivers:
        <span style="color:#66d9ef">var</span> distance: <span style="color:#a6e22e">float</span> <span style="color:#f92672">=</span> (river[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> river[<span style="color:#ae81ff">0</span>])<span style="color:#f92672">.</span>length()
        <span style="color:#66d9ef">var</span> step :<span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> distance
        <span style="color:#66d9ef">var</span> t :<span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>
        <span style="color:#66d9ef">while</span> t <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">for</span> offset <span style="color:#f92672">in</span> OFFSETS:
                <span style="color:#66d9ef">var</span> position: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> river[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>linear_interpolate(river[<span style="color:#ae81ff">1</span>], t) <span style="color:#f92672">+</span> offset
                <span style="color:#66d9ef">if</span> position<span style="color:#f92672">.</span>x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> width <span style="color:#f92672">&lt;=</span> position<span style="color:#f92672">.</span>x <span style="color:#f92672">or</span> position<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> height <span style="color:#f92672">&lt;=</span> position<span style="color:#f92672">.</span>y:
                    <span style="color:#66d9ef">continue</span>

                image<span style="color:#f92672">.</span>set_pixelv(position, <span style="color:#a6e22e">Color</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>))
            t <span style="color:#f92672">+=</span> step
    image<span style="color:#f92672">.</span>unlock()
    image<span style="color:#f92672">.</span>generate_mipmaps()

    <span style="color:#66d9ef">var</span> out :<span style="color:#f92672">=</span> <span style="color:#a6e22e">ImageTexture</span><span style="color:#f92672">.</span>new()
    out<span style="color:#f92672">.</span>create_from_image(image)
    <span style="color:#66d9ef">return</span> out
</pre>
</body>
</html>
