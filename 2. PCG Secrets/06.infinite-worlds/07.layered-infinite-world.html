<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>TmpKi1GAOEKRq</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <style type="text/css">:root {--c-caption: grey;--c-blue: #26bfe3;--c-green: #02e180;--c-orange: #f2971a;--c-pink: #e3266f;--c-bg: #fff;--c-bg-alt: #f5f5f5;--c-text-header: #fff;--c-text-body: #95989a;--padding: 20px;--padding-inv: calc(-1 * var(--padding));--fonts: "Open Sans", -apple-system, system-ui, "Segoe UI", "Roboto","Helvetica Neue", Arial, sans-serif;--font-size: 1.1rem;}html {font-size: 100%;}body {color: #444;font-family: var(--fonts);font-size: var(--font-size);line-height: 1.7;padding: 1em;margin: auto;max-width: 800px;background: #fefefe;}a {color: #0645ad;text-decoration: none;}a:visited {color: #0b0080;}a:hover {color: #06e;}a:active {color: #faa700;}a:focus {outline: thin dotted;}a::selection {background: rgba(255, 255, 0, 0.3);color: #0645ad;}*::selection {background: rgba(255, 255, 0, 0.3);color: #000;}p {margin: 1em 0;}.caption {text-align: center;color: var(--c-caption);font-style: italic;}.note,.tips,.warning {display: block;width: calc(100% - var(--padding) * 2);padding: 0 var(--padding);padding-bottom: var(--padding);background-color: var(--c-bg-alt);}.note:before,.tips:before,.warning:before {display: block;margin: 0 var(--padding-inv) 10px var(--padding-inv);padding-left: var(--padding);font-style: bold;color: white;}.note:before {content: "Note";background-color: var(--c-blue);}.tips:before {content: "Tips";background-color: var(--c-pink);}.warning:before {content: "Warning";background-color: var(--c-orange);}img {max-width: 100%;}h1,h2,h3,h4,h5,h6 {color: #111;line-height: 125%;margin-top: 2em;font-weight: normal;}h4,h5,h6 {font-weight: bold;}h1 {font-size: 2.5em;}h2 {font-size: 2em;}h3 {font-size: 1.5em;}h4 {font-size: 1.2em;}blockquote {color: #666666;margin: 0;padding-left: 3em;border-left: 0.5em #eee solid;}hr {display: block;height: 2px;border: 0;border-top: 1px solid #aaa;border-bottom: 1px solid #eee;margin: 1em 0;padding: 0;}pre,code,kbd,samp {color: #0084b8;font-family: monospace, monospace;}pre {background-color: #f9f9f9;padding: 1em;font-size: 14px;white-space: pre-wrap;word-wrap: break-word;}code {white-space: pre-wrap;}b,strong {font-weight: bold;}dfn {font-style: italic;color: var(--c-blue);}ins {background: #ff9;color: #000;text-decoration: none;}ul,ol {margin: 1em 0;padding: 0 0 0 2em;}li p:last-child {margin-bottom: 0;}ul ul,ol ol {margin: 0.3em 0;}dl {margin-bottom: 1em;}dt {font-weight: bold;margin-bottom: 0.8em;}dd {margin: 0 0 0.8em 2em;}dd:last-child {margin-bottom: 0;}img {border: 0;-ms-interpolation-mode: bicubic;vertical-align: middle;}figure {display: block;text-align: center;margin: 1em 0;}figure img {border: none;margin: 0 auto;}figcaption {font-size: 0.8em;font-style: italic;margin: 0 0 0.8em;}.author {font-size: 1.2em;text-align: center;}tag {min-width: 3.2em;text-align: center;border-radius: 8px;padding: 0 4px;margin-bottom: 0;margin-top: 4px;margin-right: 0.2em;display: inline-block;color: white;}tag.update {background: var(--c-blue);}tag.new {background: var(--c-green);}tag.update:after {content: "update";}tag.new:after {content: "new";}button {background-color: var(--c-blue);color: white;border: none;cursor: pointer;line-height: 2rem;font-size: 1.2rem;margin: 0.75rem 0;overflow: visible;padding: 0.75rem 1.5rem;border-radius: 1rem;transition: background-color $transition-duration;white-space: nowrap;}</style>
</head>
<body>
<h1 id="layered-infinite-world-generation">Layered infinite world generation</h1>
<p>A powerful technique to use when creating procedural worlds is layering.</p>
<p>You generate the first pass of data with a given algorithm, store it, and forward it to the next processing function, that acts as a separate layer. Each layer only processes data from underlying ones.</p>
<p>You work in passes until you reach the desired result.</p>
<p><img src="data:image/png;base64,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" /></p>
<p>We’ll use that to generate a richer world than in the previous lessons, using five layers:</p>
<ol type="1">
<li>We will first generate random points, our algorithm’s “seeds”.</li>
<li>From these points, we may spawn a planet.</li>
<li>If the sector has a planet, that planet might have a moon.</li>
<li>If neighboring sectors both have planets, we connect them with a trading route.</li>
<li>And finally, we may create asteroid belts around planets.</li>
</ol>
<p>For the trading routes, we need to check neighboring sectors. To do this safely, the algorithm works by shrinking each new layer by one sector compared to the previous one.</p>
<p><em>Layered generation works a bit like multipass shaders. You run the first pass on your image or mesh, and subsequent passes process the previous pass’s output.</em></p>
<p>This lesson is long, so it’s split into two parts. In this part, we’ll set up the layered generation and drawing code. In the next part, we’ll generate the world’s planets, moons, and everything you can see on the screenshot above.</p>
<p>Brace yourselves because the class we will write one has a lot of code, although the layering system itself is only a small part of it.</p>
<h2 id="setting-up-the-scene">Setting up the scene</h2>
<p>We need a scene that’s similar to the previous lessons, but we need to attach a different script to its root node. Duplicate the <code>BlueNoiseWorldGenerator.tscn</code>, name it <code>LayeredWorldGenerator.tscn</code>, open it, and rename its root node accordingly.</p>
<p><img src="data:image/png;base64,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" /></p>
<p>In the image, you’ll notice we use a <em>CanvasLayer</em> and a <em>ColorRect</em> node. This allows us to not modify the project’s clear color, but instead have a specific background for this scene.</p>
<p>Remove the <em>LayeredWorldGenerator</em>’s script and attach a new one to it, so we have a new GDScript file to work with.</p>
<h2 id="coding-the-layer-system">Coding the layer system</h2>
<p>Open the script and let’s start coding with the generator’s foundations: the layer system.</p>
<p>We start by defining some constants we’ll use later.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e">## Generates an infinite world using a layered approach, allowing each layer to</span>
<span style="color:#75715e">## access the previous layers&#39; data. Each layer is smaller than the next by one</span>
<span style="color:#75715e">## sector to access the neighbors&#39; data.</span>
class_name LayeredWorldGenerator
<span style="color:#66d9ef">extends</span> WorldGenerator

<span style="color:#75715e"># The following constants define the base size of planets, moons, and asteroids</span>
<span style="color:#75715e"># in pixels. We&#39;ll use them to calculate their position relative to one another</span>
<span style="color:#75715e"># and to draw them.</span>
<span style="color:#66d9ef">const</span> PLANET_BASE_SIZE :<span style="color:#f92672">=</span> <span style="color:#ae81ff">96</span>
<span style="color:#66d9ef">const</span> MOON_BASE_SIZE :<span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>
<span style="color:#66d9ef">const</span> ASTEROID_BASE_SIZE :<span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span>

<span style="color:#75715e"># We use this array of coordinates to loop over the eight neighbors around any</span>
<span style="color:#75715e"># sector.</span>
<span style="color:#66d9ef">const</span> NEIGHBORS :<span style="color:#f92672">=</span> [
    <span style="color:#a6e22e">Vector2</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>),
    <span style="color:#a6e22e">Vector2</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>),
    <span style="color:#a6e22e">Vector2</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>),
    <span style="color:#a6e22e">Vector2</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>),
    <span style="color:#a6e22e">Vector2</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>),
    <span style="color:#a6e22e">Vector2</span>(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>),
    <span style="color:#a6e22e">Vector2</span>(<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>),
    <span style="color:#a6e22e">Vector2</span>(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
]
</pre>
<p>Like before, we’ll store generated data for sectors inside a dictionary. But this time, instead of storing an array, for each sector, we’ll have a dictionary.</p>
<p>Each layer will be a separate key: “seeds”, “planet”, and so on. The corresponding values will be arrays of dictionaries, or a single dictionary.</p>
<p>We use dictionaries because they are both fast and flexible. You can extend them with more data anytime if you need to, and as you will see in the <code>_draw()</code> function, they are convenient to check existing keys and available data. They are a great prototyping tool and an efficient data structure.</p>
<p>We define a constant representing the data structure for empty layers.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># This constant holds the template for the data output by our algorithms for</span>
<span style="color:#75715e"># each of the five layers. We will loop over the keys to generate each layer</span>
<span style="color:#75715e"># and duplicate the dictionary to initialize newly generated sectors.</span>
<span style="color:#66d9ef">const</span> LAYERS <span style="color:#f92672">=</span> {
    seeds <span style="color:#f92672">=</span> [],
    planet <span style="color:#f92672">=</span> {},
    moons <span style="color:#f92672">=</span> [],
    travel_lanes <span style="color:#f92672">=</span> [],
    asteroids <span style="color:#f92672">=</span> [],
}
</pre>
<p>We initialize the layers that can generate multiple elements per sector as arrays. In the case of the planet, you can only have one per sector, so we directly initialize it as an empty dictionary.</p>
<p>Our first layer will place three random points inside a sector. We call them seeds as we will not use them as world entities but rather see if we want to generate a planet or not in that sector, depending on the area they cover.</p>
<p><img src="data:image/png;base64,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" /></p>
<p>Unlike before, we want to generate layers one at a time. Instead of processing each sector individually, possibly in parallel, we need the first layer to finish running before starting the second pass. The <code>WorldGenerator.generate()</code> function that calls <code>_generate_sector()</code> in a loop does not allow for that.</p>
<p>That’s why in this class, we need to override the parent class’s <code>generate()</code> method.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e">## Generates the world with a layered approach. Each layer requires another</span>
<span style="color:#75715e">## layer before it to already be generated.</span>
<span style="color:#75715e">## As we add layers, we shrink them by one sector so that sectors on upper</span>
<span style="color:#75715e">## layers can access data from neighboring sectors.</span>
<span style="color:#66d9ef">func</span> generate() <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#75715e"># We need to calculate each layer&#39;s index to shrink the range of generated</span>
    <span style="color:#75715e"># sectors every time we move up one layer.</span>
    <span style="color:#66d9ef">var</span> index :<span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
    <span style="color:#75715e"># Our layer names correspond to the keys in our layers dictionary. As</span>
    <span style="color:#75715e"># dictionaries are ordered in Godot, we can loop over them to generate</span>
    <span style="color:#75715e"># seeds, planets, moons, travel lanes, and asteroids in that order.</span>
    <span style="color:#66d9ef">for</span> layer <span style="color:#f92672">in</span> LAYERS:
        index <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#75715e"># The next two full groups calculate the grid of sectors that we process</span>
        <span style="color:#75715e"># in a given layer. We use the index to shrink the grid by one cell</span>
        <span style="color:#75715e"># every time we move up one layer.</span>
        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(
            _current_sector<span style="color:#f92672">.</span>x <span style="color:#f92672">-</span> _half_sector_count <span style="color:#f92672">+</span> index,
            _current_sector<span style="color:#f92672">.</span>x <span style="color:#f92672">+</span> _half_sector_count <span style="color:#f92672">-</span> index
        ):
            <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(
                _current_sector<span style="color:#f92672">.</span>y <span style="color:#f92672">-</span> _half_sector_count <span style="color:#f92672">+</span> index,
                _current_sector<span style="color:#f92672">.</span>y <span style="color:#f92672">+</span> _half_sector_count <span style="color:#f92672">-</span> index
            ):
                <span style="color:#75715e"># In this class, we decided to make the functions take the</span>
                <span style="color:#75715e"># sectors coordinate as their argument because after we wrote</span>
                <span style="color:#75715e"># the code, we realized that we needed that Vector2 in every</span>
                <span style="color:#75715e"># method.</span>
                <span style="color:#66d9ef">var</span> sector <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(x, y)
                <span style="color:#75715e"># For each layer, we call a corresponding function. In Godot</span>
                <span style="color:#75715e"># 4.0, we will be able to shorten this code by directly mapping</span>
                <span style="color:#75715e"># layers to a function in the form of a dictionary. But in</span>
                <span style="color:#75715e"># version 3.2, the match keyword works fine.</span>
                match layer:
                    <span style="color:#e6db74">&quot;seeds&quot;</span>:
                        <span style="color:#75715e"># We initialize every sector&#39;s data before generating</span>
                        <span style="color:#75715e"># the first layer.</span>
                        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> _sectors<span style="color:#f92672">.</span>has(sector):
                            _sectors[sector] <span style="color:#f92672">=</span> LAYERS<span style="color:#f92672">.</span>duplicate(true)
                        <span style="color:#75715e"># Here is the layer&#39;s processing. It&#39;s a function call.</span>
                        <span style="color:#75715e"># The main difference compared to what we had before is we&#39;ll run the </span>
                        <span style="color:#75715e"># `_generate_seeds_at()` method over all sectors before moving to the</span>
                        <span style="color:#75715e"># next layer.</span>
                        _generate_seeds_at(sector)
                    <span style="color:#e6db74">&quot;planet&quot;</span>:
                        _generate_planets_at(sector)
                    <span style="color:#e6db74">&quot;moons&quot;</span>:
                        _generate_moons_at(sector)
                    <span style="color:#e6db74">&quot;travel_lanes&quot;</span>:
                        _generate_travel_lanes_at(sector)
                    <span style="color:#e6db74">&quot;asteroids&quot;</span>:
                        _generate_asteroids_at(sector)
    <span style="color:#75715e"># Once we finished generating everything, we trigger a drawing update.</span>
    <span style="color:#75715e"># Calling `CanvasItem.update()` causes the engine to call this node&#39;s `_draw()` virtual callback.</span>
    update()
</pre>
<p>We have yet to define our five functions. To avoid errors, you can define them and leave them empty for now. That way, the GDScript compiler won’t get in your way.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">func</span> _generate_seeds_at(sector: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">pass</span>


<span style="color:#66d9ef">func</span> _generate_planets_at(sector: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">pass</span>


<span style="color:#66d9ef">func</span> _generate_moons_at(sector: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">pass</span>


<span style="color:#66d9ef">func</span> _generate_travel_lanes_at(sector: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">pass</span>


<span style="color:#66d9ef">func</span> _generate_asteroids_at(sector: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">pass</span>
</pre>
<h2 id="drawing-the-data">Drawing the data</h2>
<p>Even though we don’t have any data to draw yet, and we haven’t written the generation, we will add the <code>_draw()</code> function next. Thanks to the dictionaries and arrays that we are using, you will see that we can easily only draw what is available.</p>
<p>If you know what you are looking to generate from the start and have some sketch of the results you want on paper, you can write that function upfront to visualize your functions’ output as you implement them.</p>
<p>We first define a <code>show_debug</code> property to toggle drawing of the grid and some data points.</p>
<p>We use it to toggle the <em>GridDrawer</em> node’s visibility at the start of the game.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e">## Hides or shows the grid and the planetary seeding points.</span>
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> show_debug :<span style="color:#f92672">=</span> true <span style="color:#66d9ef">setget</span> _set_show_debug

<span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> _grid_drawer :<span style="color:#f92672">=</span> <span style="color:#f92672">$</span>GridDrawer


<span style="color:#75715e"># This code is similar to what we had in previous lessons. We generate the world and initialize the GridDrawer.</span>
<span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
    generate()
    _grid_drawer<span style="color:#f92672">.</span>setup(sector_size, sector_axis_count)
    _grid_drawer<span style="color:#f92672">.</span>visible <span style="color:#f92672">=</span> show_debug


<span style="color:#75715e">## Toggles the GridDrawer&#39;s visibility and requests a call to the `_draw()` function.</span>
<span style="color:#75715e">## As you&#39;ll see in a second, we&#39;ll use the `show_debug` property to toggle the drawing of </span>
<span style="color:#75715e">## seeding points.</span>
<span style="color:#66d9ef">func</span> _set_show_debug(value: <span style="color:#a6e22e">bool</span>) <span style="color:#f92672">-&gt;</span> void:
    show_debug <span style="color:#f92672">=</span> value
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_inside_tree():
        yield(self, <span style="color:#e6db74">&quot;ready&quot;</span>)
    _grid_drawer<span style="color:#f92672">.</span>visible <span style="color:#f92672">=</span> show_debug
    update()
</pre>
<p>Here is the <code>_draw()</code> function.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># This is where we draw the data generated by our algorithm. This function is</span>
<span style="color:#75715e"># available on every node that inherits `CanvasItem`, and it gives us access to a</span>
<span style="color:#75715e"># range of methods to draw geometric shapes.</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># The `_draw()` callback only updates when necessary:</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># 1. When the node first gets added to the tree.</span>
<span style="color:#75715e"># 2. When we toggle node visibility on and off.</span>
<span style="color:#75715e"># 3. When we call the `update()` function manually.</span>
<span style="color:#66d9ef">func</span> _draw() <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#75715e"># We loop over all the data stored in all the sectors and draw everything,</span>
    <span style="color:#75715e"># even if it is right outside the screen.</span>
    <span style="color:#75715e"># You will want to adjust your generation settings, like the number of</span>
    <span style="color:#75715e"># sectors you draw per axis, so it doesn&#39;t go too far out the screen.</span>
    <span style="color:#66d9ef">for</span> data <span style="color:#f92672">in</span> _sectors<span style="color:#f92672">.</span>values():
        <span style="color:#75715e"># Each of the `if` and `for` blocks below draws one layer.</span>

        <span style="color:#75715e"># For the first layer, the seeds, we only draw if `show_debug` is on</span>
        <span style="color:#75715e"># because they don&#39;t contribute to the final world&#39;s entities.</span>
        <span style="color:#66d9ef">if</span> show_debug <span style="color:#f92672">and</span> data<span style="color:#f92672">.</span>seeds:
            <span style="color:#66d9ef">for</span> point <span style="color:#f92672">in</span> data<span style="color:#f92672">.</span>seeds:
                draw_circle(point, <span style="color:#ae81ff">12</span>, <span style="color:#a6e22e">Color</span>(<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>))
        <span style="color:#75715e"># For the rest of the layers, we check if the corresponding data exists</span>
        <span style="color:#75715e"># in the `_sectors` dictionary. </span>
        <span style="color:#75715e">#</span>
        <span style="color:#75715e"># For every layer that is an array, the for loop takes care of that for us. </span>
        <span style="color:#75715e"># If the array is empty, the loop will instantly end. </span>
        <span style="color:#75715e">#</span>
        <span style="color:#75715e"># In the planet&#39;s case, we need to check that the dictionary is not empty.</span>
        <span style="color:#75715e"># We draw circles for the planet, moons, and asteroids, and a line for</span>
        <span style="color:#75715e"># the trading routes.</span>
        <span style="color:#66d9ef">if</span> data<span style="color:#f92672">.</span>planet:
            <span style="color:#75715e"># `draw_circle()` takes a position, radius in pixels, and color as its arguments.</span>
            <span style="color:#75715e"># We&#39;ll generate the position and scale in the `_generate_planets_at()` function.</span>
            <span style="color:#75715e"># To get the radius in pixels, we multiply the scale by our base size constant.</span>
            draw_circle(data<span style="color:#f92672">.</span>planet<span style="color:#f92672">.</span>position, PLANET_BASE_SIZE <span style="color:#f92672">*</span> data<span style="color:#f92672">.</span>planet<span style="color:#f92672">.</span>scale, <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>bisque)
        <span style="color:#66d9ef">for</span> moon <span style="color:#f92672">in</span> data<span style="color:#f92672">.</span>moons:
            draw_circle(moon<span style="color:#f92672">.</span>position, MOON_BASE_SIZE <span style="color:#f92672">*</span> moon<span style="color:#f92672">.</span>scale, <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>aquamarine)
        <span style="color:#66d9ef">for</span> path <span style="color:#f92672">in</span> data<span style="color:#f92672">.</span>travel_lanes:
            <span style="color:#66d9ef">var</span> start: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> path<span style="color:#f92672">.</span>source
            <span style="color:#66d9ef">var</span> end: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> path<span style="color:#f92672">.</span>destination
            <span style="color:#75715e"># The arguments for `draw_line()` are the start and end position, the line&#39;s color, </span>
            <span style="color:#75715e"># and its width in pixels.</span>
            draw_line(start, end, <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>cornflower, <span style="color:#ae81ff">6.0</span>)
        <span style="color:#66d9ef">for</span> asteroid <span style="color:#f92672">in</span> data<span style="color:#f92672">.</span>asteroids:
            draw_circle(asteroid<span style="color:#f92672">.</span>position, ASTEROID_BASE_SIZE <span style="color:#f92672">*</span> asteroid<span style="color:#f92672">.</span>scale, <span style="color:#a6e22e">Color</span><span style="color:#f92672">.</span>orangered)
</pre>
<p>We’ll wrap up this lesson by generating the seeding points, so you can see the drawing code in action.</p>
<h2 id="generating-the-seeding-points">Generating the seeding points</h2>
<p>On the first layer, we generate three random points per sector. Together, we can treat them as a triangle and use its area as a threshold to spawn a planet. You will see on the resulting generation this produces varied positions and sizes for the planets. Even without smoothing or processing the initial result, we get a relatively natural distribution.</p>
<p><img src="data:image/png;base64,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" /></p>
<p>The advantage of starting with seeding points is that any layer can reuse them differently. You can also smooth out their position, grow or shrink them, and do whatever you need to fine-tune the generator’s output. There is no hard rule there. As we mentioned before, all that matters is the output and how the final world looks. There’s a lot of experimentation to do and two or three points give you a lot of flexibility in the way you process and interpret them.</p>
<p><em>If you generate two seeding points instead of three, you can interpret them as a circle’s diameter. You can then use that circle to define a specific area, for example to spawn enemies, loot, and more.</em></p>
<p>We add two variables to add some margin to our sectors, as in the previous lesson, and implement the <code>_generate_seeds_at()</code> function. You can replace the empty definition with the following code.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e">## Percentage to keep the planetary seeding points away from the sector edges.</span>
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> sector_margin_proportion :<span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>

<span style="color:#75715e">## The pixel value of the margin calculated from the margin percentage</span>
<span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> _sector_margin :<span style="color:#f92672">=</span> sector_size <span style="color:#f92672">*</span> sector_margin_proportion


<span style="color:#75715e">## Generates a triangle inside of the `sector`. The next layer can use it to spawn</span>
<span style="color:#75715e">## planets. We&#39;ll use the triangle&#39;s area and epicenter to randomly spawn planets.</span>
<span style="color:#66d9ef">func</span> _generate_seeds_at(sector: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#75715e"># To update the map generation, we have to generate the layers in order. </span>
    <span style="color:#75715e"># To do so conveniently, we&#39;ll call the `generate()` method again, triggering a call </span>
    <span style="color:#75715e"># to this and other functions even for generated sectors.</span>
    <span style="color:#75715e"># Returning early from function calls in already generated sectors keeps the code</span>
    <span style="color:#75715e"># simple while prototyping. So if this sector has seeds, it means we already processed it</span>
    <span style="color:#75715e"># so we return from the function.</span>
    <span style="color:#66d9ef">if</span> _sectors[sector]<span style="color:#f92672">.</span>seeds:
        <span style="color:#66d9ef">return</span>

    <span style="color:#75715e"># We use our `make_seed_for()` function&#39;s custom data argument for</span>
    <span style="color:#75715e"># the first time. Like before, to keep the generation deterministic, we</span>
    <span style="color:#75715e"># create a unique seed for every sector, and now, for every layer too.</span>
    _rng<span style="color:#f92672">.</span>seed <span style="color:#f92672">=</span> make_seed_for(sector<span style="color:#f92672">.</span>x, sector<span style="color:#f92672">.</span>y, <span style="color:#e6db74">&quot;seeds&quot;</span>)

    <span style="color:#75715e"># Like before, we first calculate the sector&#39;s bounds, applying some margin to it.</span>
    <span style="color:#66d9ef">var</span> half_size :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(_half_sector_size, _half_sector_size)
    <span style="color:#66d9ef">var</span> margin :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(_sector_margin, _sector_margin)
    <span style="color:#66d9ef">var</span> top_left :<span style="color:#f92672">=</span> sector <span style="color:#f92672">*</span> sector_size <span style="color:#f92672">-</span> half_size <span style="color:#f92672">+</span> margin
    <span style="color:#66d9ef">var</span> bottom_right :<span style="color:#f92672">=</span> sector <span style="color:#f92672">*</span> sector_size <span style="color:#f92672">+</span> half_size <span style="color:#f92672">-</span> margin

    <span style="color:#75715e"># We then generate three points using white noise to form a triangle.</span>
    <span style="color:#75715e"># The next layer will use these points and the area and epicenter of the</span>
    <span style="color:#75715e"># corresponding triangle to spawn a planet.</span>
    <span style="color:#75715e"># We create an array of three points and save them in this sector&#39;s `seeds`</span>
    <span style="color:#75715e"># key.</span>
    <span style="color:#66d9ef">var</span> seeds :<span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> _i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>):
        <span style="color:#66d9ef">var</span> seed_position :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(
            _rng<span style="color:#f92672">.</span>randf_range(top_left<span style="color:#f92672">.</span>x, bottom_right<span style="color:#f92672">.</span>x),
            _rng<span style="color:#f92672">.</span>randf_range(top_left<span style="color:#f92672">.</span>y, bottom_right<span style="color:#f92672">.</span>y)
        )
        seeds<span style="color:#f92672">.</span>append(seed_position)
    _sectors[sector]<span style="color:#f92672">.</span>seeds <span style="color:#f92672">=</span> seeds
</pre>
<p>You will notice a pattern in each of the functions: if a given sector already has data, we return early.</p>
<p>This is due to the way we wrote the <code>generate()</code> function, which loops over all the sectors for all layers. This code is not the most optimized, but for one, it should run smoothly during development, and optimizing it would make it more complex and harder to modify, which we do not want at this stage.</p>
<p>If you test the scene now, it should look like this.</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA6kAAAIaBAMAAAAw2BbvAAAAElBMVEURIlWHzutIUWpKW6tMo/wXMGi17+wgAAAACXBIWXMAABJ0AAASdAHeZh94AAAGV0lEQVR42u3d7W3bMBSGUYPIAM4GxF3BHsCA1Q26/yx1ghZoELf+EC2RV0dAfz/Je2yJSdNmt2t57XevvzSWvixOVYOqBlUNa1C1OFUNqhpUNag+3YhKNV2jRFClSpUqVc9Vqhp3XrduRhYfU7VanKrF3YGpOi1pUKVqcaoWp6pBVWMA1WLxhKot/vqDKlWqVKlSpapBVYPqOo2oVNM1CtWUqkHVe3Whz2P2x7Xx5+qOqgZVjeaqM44BFl+/8Y+3ajz/HrZ4t2dgqjlVLZ5P1RpULU5Vg6oGVQ1rULU4VQ2qGlQ1qFK1BlWLU9WgqkFVwxpULU7V4lQ1qGpQ1bAGVYsnUX3sR74tTpUqVQ2qGtag2uMalWo+1ea/n++xz6NEpfrFo7ZRreuqBtWZr/IeVb1X577K3YE38l51Bu7sueorG2dgDaoa1qBqcaoam1J96gs9qlSpUqVKlaoGVQ2qGtaganGqFqeqQVWDqoY1qFqcqgZVDaoaVKlag6rFqWpQ1aCqYQ2qFqeqQVWDqgZVqtaganGqGlQ1qGpYg6rFqVqcqgZVDaoa1qBqcaqrNUqlmk919v/DT7VL1UrVe5XqCM9VqulUS2R5dVJt+FSlSpUqVaqeq1TTNubfeizeXaM0/42VFqdK1R1Yw2lJg2rexhoPWapUNahqUNWwBlWLU9WgqkFVgypVi1O1OFUNqhpUNaxB1eJUNahqUNWgStUaVC1OVYOqBlUNa1C1OFWLU9WgqkFVwxpULU5Vg6pGs+vdle7ae427A1ucqgZVDaoaVKlag6rFqWpQ1aCqYQ2qFqeqQVWDqgZVDWtQtThVjU2qRqWaUDWoUqVKleo6H2nxXHUG1qBK1RpULU5Vg6oGVQ1rULU4VYtT1aCqQVXDGlQtTlWDqgZVDapULU7V4lQ1qGpQ1bAG1ctVolr8zuv2VP2oBtVmU3WkWqkmVA2qrR5W3ZyWyqCqsfwrJ+Y1Iqg2eON09nksqXr7ZNepalBN98yjmvIkM94duK/LGZiqBlUNqhrWoGpxqhpUNahqUKVqcaoWp6pBVYOqhjWoWpyqxvONEpUqVYtTtThVqk5LGlQ1qGpYg6rFqWpQ1aCqQZWqNagOscZENZ/q23Simk51OkxUs6m+nQ/HE9VkqsfD4XCmmkx1uqhOVHOpXm7Ah4dvwVSpUl288XEDfvgWTJUq1cUb50/VI9VMqm+/VU9Uk6keqeZTnaaJajLVi+nu8odqqtPSz4/j7/TDaSmV6qYb1qBqcaoaVDWoaliDqsWpWpyqxnZVg2o+1RKVakLV6GPx668uqoOrBtV0d+BCNWODasZG8VzttFFii6/O7Krx0EGWKlWq7sBUNahqWINq6jUK1Xyq174hSJUqVapUF2lEpep8SlWDqgbVjI2gmq9RrpzcqI6vGiOolqCaTzXa31JyP1crVXd5d2CqzT7SanFfr2pQ1aBK1eJULU5Vg6oG1Zc0olJN1/BvzalSpUrVc5WqhjWoWpyqBlUNqhpUqVqcqsWpalDVoKphDaoWp6pBVYOqBlWq1qBqcaoaVDWoaliDqsWpWpyqBlUNqhrWoGpxqhpUNahqUKVqcaoWp6pBVYOqxp/r3ZXu2nuNuwNbnKoGVQ2qGlSpWoOqxalqUNWgqmENqhanqkFVg6oGVQ1rULU4VQ2qGlQ1rEHV4lQtTlWDqgZVDWt8XqVSzacaUalSpUqV6jrP1fBcdT6lqkFVg6oGVaoWp2pxqhpUNahqWIOqxalqUNWgqkGVqjWoWpyqBtWNNr79ABXVBI2ISpXqS65SqeZTjaCa77lKNeMZmCpVi/t6VYOqhjWoWpyqBlUNqhpUNaxB1eJUR2n8/d1PqlSpUqVKlaqGNahavINGpZqvsd5PqlF9XSOiUqVqcXdgizsDa1DdZiOCKlWqrRrNl6fahWqlStVpaeN3YKoaVL9chWpC1ftvolSHWaNQpUp1kDtwpep8StXiVDWojtO4/8lNdZhGeeTbilSpUnUHptqyUXZUNahqUNWwBlWLU9WgqkFVgypVi1O1OFUNqhpUNaxB1eJUNaj+9/r2o0BUqVKlSpUqVQ2qGlQ1rEHV4lQtTlWDqgZVDWtQtThVDaoaVDWoUrUGVYtT1aCqQVXDGlQtTlWDqgZVDapUrUHV4lQ1qGpQ1bDGNhq/AAB2BqGqGzhUAAAAAElFTkSuQmCC" /></p>
<p>Now we have the seeds, we can use them to generate the planets and build other layers from there. We’ll do that in the next lesson.</p>
</body>
</html>
