<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Tmp4N0RNPvgr7</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <style type="text/css">:root {--c-caption: grey;--c-blue: #26bfe3;--c-green: #02e180;--c-orange: #f2971a;--c-pink: #e3266f;--c-bg: #fff;--c-bg-alt: #f5f5f5;--c-text-header: #fff;--c-text-body: #95989a;--padding: 20px;--padding-inv: calc(-1 * var(--padding));--fonts: "Open Sans", -apple-system, system-ui, "Segoe UI", "Roboto","Helvetica Neue", Arial, sans-serif;--font-size: 1.1rem;}html {font-size: 100%;}body {color: #444;font-family: var(--fonts);font-size: var(--font-size);line-height: 1.7;padding: 1em;margin: auto;max-width: 800px;background: #fefefe;}a {color: #0645ad;text-decoration: none;}a:visited {color: #0b0080;}a:hover {color: #06e;}a:active {color: #faa700;}a:focus {outline: thin dotted;}a::selection {background: rgba(255, 255, 0, 0.3);color: #0645ad;}*::selection {background: rgba(255, 255, 0, 0.3);color: #000;}p {margin: 1em 0;}.caption {text-align: center;color: var(--c-caption);font-style: italic;}.note,.tips,.warning {display: block;width: calc(100% - var(--padding) * 2);padding: 0 var(--padding);padding-bottom: var(--padding);background-color: var(--c-bg-alt);}.note:before,.tips:before,.warning:before {display: block;margin: 0 var(--padding-inv) 10px var(--padding-inv);padding-left: var(--padding);font-style: bold;color: white;}.note:before {content: "Note";background-color: var(--c-blue);}.tips:before {content: "Tips";background-color: var(--c-pink);}.warning:before {content: "Warning";background-color: var(--c-orange);}img {max-width: 100%;}h1,h2,h3,h4,h5,h6 {color: #111;line-height: 125%;margin-top: 2em;font-weight: normal;}h4,h5,h6 {font-weight: bold;}h1 {font-size: 2.5em;}h2 {font-size: 2em;}h3 {font-size: 1.5em;}h4 {font-size: 1.2em;}blockquote {color: #666666;margin: 0;padding-left: 3em;border-left: 0.5em #eee solid;}hr {display: block;height: 2px;border: 0;border-top: 1px solid #aaa;border-bottom: 1px solid #eee;margin: 1em 0;padding: 0;}pre,code,kbd,samp {color: #0084b8;font-family: monospace, monospace;}pre {background-color: #f9f9f9;padding: 1em;font-size: 14px;white-space: pre-wrap;word-wrap: break-word;}code {white-space: pre-wrap;}b,strong {font-weight: bold;}dfn {font-style: italic;color: var(--c-blue);}ins {background: #ff9;color: #000;text-decoration: none;}ul,ol {margin: 1em 0;padding: 0 0 0 2em;}li p:last-child {margin-bottom: 0;}ul ul,ol ol {margin: 0.3em 0;}dl {margin-bottom: 1em;}dt {font-weight: bold;margin-bottom: 0.8em;}dd {margin: 0 0 0.8em 2em;}dd:last-child {margin-bottom: 0;}img {border: 0;-ms-interpolation-mode: bicubic;vertical-align: middle;}figure {display: block;text-align: center;margin: 1em 0;}figure img {border: none;margin: 0 auto;}figcaption {font-size: 0.8em;font-style: italic;margin: 0 0 0.8em;}.author {font-size: 1.2em;text-align: center;}tag {min-width: 3.2em;text-align: center;border-radius: 8px;padding: 0 4px;margin-bottom: 0;margin-top: 4px;margin-right: 0.2em;display: inline-block;color: white;}tag.update {background: var(--c-blue);}tag.new {background: var(--c-green);}tag.update:after {content: "update";}tag.new:after {content: "new";}button {background-color: var(--c-blue);color: white;border: none;cursor: pointer;line-height: 2rem;font-size: 1.2rem;margin: 0.75rem 0;overflow: visible;padding: 0.75rem 1.5rem;border-radius: 1rem;transition: background-color $transition-duration;white-space: nowrap;}</style>
</head>
<body>
<h1 id="generating-new-sectors-on-the-fly">Generating new sectors on the fly</h1>
<p>We need to update the world as the player moves through it. Right now, we only have a <code>generate()</code> method. While we could call it every time the player changes sector, we’d be wasting a lot of processing power, regenerating already present sectors.</p>
<p>Instead, we only want to generate sectors as needed. We will consider that the player moves along a given axis, either X or Y (or both), and generate an entire row or column of new sectors in that direction on the fly.</p>
<p>Procedural content generation can be so heavy that you don’t want to calculate what you don’t need. While I wouldn’t recommend optimizing a lot while prototyping, avoiding to regenerate the entire grid of sectors around the player continually is the kind of optimization you would need early on <em>anyway</em>. It doesn’t get in the way of the procedural generation code. So we thought we might as well show you how to implement it from the start.</p>
<p>The function that generates new sectors as the player moves should be on the parent <code>WorldGenerator</code> class because it will benefit all of the infinite procedural world generators.</p>
<p>We will add one method called <code>_update_sectors()</code> that will call another method twice, <code>_update_along_axis()</code>. This second method will walk along one axis and free or generate a row or column of sectors perpendicular to that axis.</p>
<p>For example, if the player moves to the right, we’ll add a new column of sectors on the grid’s rightmost and delete the leftmost column.</p>
<p><img src="data:image/png;base64,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" /></p>
<p>The <code>_update_along_axis()</code> function below works both for the X and the Y axes, so you have to wrap your head around the logic that makes it work for those two cases.</p>
<p>Open the <code>WorldGenerator.gd</code> script and add the following functions.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e">## Updates generated sectors around the player based on `difference`, a cell</span>
<span style="color:#75715e">## offset.</span>
<span style="color:#75715e">## The difference is in grid coordinates. It tells us which neighbor sector the player entered.</span>
<span style="color:#66d9ef">func</span> _update_sectors(difference: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#75715e"># We call `_update_along_axis()` twice, once for each axis.</span>
    <span style="color:#75715e"># The function returns if the `difference` is irrelevant.</span>
    <span style="color:#75715e"># But calling it twice would make the code work in the edge case the player moved</span>
    <span style="color:#75715e"># diagonally and we need to generate both a row and a column of sectors.</span>
    _update_along_axis(AXIS_X, difference<span style="color:#f92672">.</span>x)
    _update_along_axis(AXIS_Y, difference<span style="color:#f92672">.</span>y)


<span style="color:#75715e">## Travels along an axis and a direction, erasing sectors in the perpendicular axis that are too far</span>
<span style="color:#75715e">## away from the player and generating new sectors that come into this range.</span>
<span style="color:#66d9ef">func</span> _update_along_axis(axis: <span style="color:#a6e22e">int</span>, difference: <span style="color:#a6e22e">float</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#75715e"># If the player isn&#39;t moving along that axis, that is, if the `difference`</span>
    <span style="color:#75715e"># is `0`, we don&#39;t have anything to generate along that axis, and we return</span>
    <span style="color:#75715e"># early.</span>
    <span style="color:#66d9ef">if</span> difference <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> (axis <span style="color:#f92672">!=</span> AXIS_X <span style="color:#f92672">and</span> axis <span style="color:#f92672">!=</span> AXIS_Y):
        <span style="color:#66d9ef">return</span>

    <span style="color:#75715e"># We&#39;re going to use the `difference` argument in calculations below to determine the sectors to</span>
    <span style="color:#75715e"># generate and delete.</span>
    <span style="color:#75715e"># Depending on the direction the player is moving, we need to correct for the calculations</span>
    <span style="color:#75715e"># below.</span>
    <span style="color:#75715e"># When `difference` is positive, we end up in situations where sectors aren&#39;t erased or added on</span>
    <span style="color:#75715e"># time. This value is there to catch those cases.</span>
    <span style="color:#66d9ef">var</span> axis_modifier :<span style="color:#f92672">=</span> <span style="color:#a6e22e">int</span>(difference <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
    <span style="color:#75715e"># We extract the `_current_sector`&#39;s row or column depending on the axis we want to walk.</span>
    <span style="color:#66d9ef">var</span> sector_axis_coordinate :<span style="color:#f92672">=</span> _current_sector<span style="color:#f92672">.</span>x <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> _current_sector<span style="color:#f92672">.</span>y
    <span style="color:#75715e"># We calculate the coordinate of the row or column of the new line of sectors to create.</span>
    <span style="color:#66d9ef">var</span> new_sector_line_index :<span style="color:#f92672">=</span> <span style="color:#a6e22e">int</span>(
        <span style="color:#75715e"># Here, notice how we use `axis_modifier`. If the player is moving right or down, we need to</span>
        <span style="color:#75715e"># subtract `1` to the `_half_sector_count` to get the new sector&#39;s coordinate along that</span>
        <span style="color:#75715e"># axis.</span>
        sector_axis_coordinate <span style="color:#f92672">+</span> (_half_sector_count <span style="color:#f92672">-</span> axis_modifier) <span style="color:#f92672">*</span> difference <span style="color:#f92672">+</span> difference
    )

    <span style="color:#75715e"># We find the range of coordinates of the row or column *perpendicular* to the</span>
    <span style="color:#75715e"># axis we&#39;re updating.</span>
    <span style="color:#75715e"># We want to generate and delete new sectors in this range.</span>
    <span style="color:#66d9ef">var</span> other_axis_position :<span style="color:#f92672">=</span> _current_sector<span style="color:#f92672">.</span>y <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> _current_sector<span style="color:#f92672">.</span>x
    <span style="color:#66d9ef">var</span> other_axis_min :<span style="color:#f92672">=</span> other_axis_position <span style="color:#f92672">-</span> _half_sector_count
    <span style="color:#66d9ef">var</span> other_axis_max :<span style="color:#f92672">=</span> other_axis_position <span style="color:#f92672">+</span> _half_sector_count

    <span style="color:#75715e"># We generate a new entire row or column perpendicular to the axis along which we&#39;re moving.</span>
    <span style="color:#75715e"># The values `new_sector_line_index` above and `other_axis_coordinate` together represent the</span>
    <span style="color:#75715e"># coordinates of a row or column of sectors.</span>
    <span style="color:#66d9ef">for</span> other_axis_coordinate <span style="color:#f92672">in</span> range(other_axis_min, other_axis_max):
        <span style="color:#66d9ef">var</span> x :<span style="color:#f92672">=</span> new_sector_line_index <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> other_axis_coordinate
        <span style="color:#66d9ef">var</span> y :<span style="color:#f92672">=</span> other_axis_coordinate <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> new_sector_line_index
        _generate_sector(x, y)

    <span style="color:#75715e"># We then want to delete the row or column on the opposite end of the grid.</span>
    <span style="color:#75715e"># To do so, we calculate the corresponding line of sector&#39;s coordinate along the axis we&#39;re walking.</span>
    <span style="color:#66d9ef">var</span> obsolete_sector_line_index :<span style="color:#f92672">=</span> <span style="color:#a6e22e">int</span>(new_sector_line_index <span style="color:#f92672">+</span> sector_axis_count <span style="color:#f92672">*</span> <span style="color:#f92672">-</span>difference)

    <span style="color:#75715e"># We erase the entire row or column that&#39;s farthest from the player.</span>
    <span style="color:#66d9ef">for</span> other_axis_coordinate <span style="color:#f92672">in</span> range(other_axis_min, other_axis_max):
        <span style="color:#75715e"># We first calculate each sector&#39;s coordinates as a Vector2 as that&#39;s how we indexed them in</span>
        <span style="color:#75715e"># the `_sectors` dictionary.</span>
        <span style="color:#66d9ef">var</span> key :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(
            obsolete_sector_line_index <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> other_axis_coordinate,
            other_axis_coordinate <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> obsolete_sector_line_index
        )

        <span style="color:#75715e"># We free all asteroids in this sector and remove the corresponding key.</span>
        <span style="color:#66d9ef">if</span> _sectors<span style="color:#f92672">.</span>has(key):
            <span style="color:#66d9ef">var</span> sector_data: <span style="color:#a6e22e">Array</span> <span style="color:#f92672">=</span> _sectors[key]
            <span style="color:#66d9ef">for</span> d <span style="color:#f92672">in</span> sector_data:
                d<span style="color:#f92672">.</span>queue_free()
            <span style="color:#66d9ef">var</span> _found :<span style="color:#f92672">=</span> _sectors<span style="color:#f92672">.</span>erase(key)

    <span style="color:#75715e"># And now we&#39;re done updating the world, we update the `_current_sector`.</span>
    <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X:
        _current_sector<span style="color:#f92672">.</span>x <span style="color:#f92672">+=</span> difference
    <span style="color:#66d9ef">else</span>:
        _current_sector<span style="color:#f92672">.</span>y <span style="color:#f92672">+=</span> difference
</pre>
<p>Next, we need to update the <code>WhiteNoiseGenerator</code> class. We will track the player’s position and, if they move too far away from the current sector, call <code>_update_sectors()</code> and update the grid position.</p>
<p>We’ll do this in <code>_physics_process()</code>. Open <code>WhiteNoiseGenerator.gd</code> and add the following code to it.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> _player :<span style="color:#f92672">=</span> <span style="color:#f92672">$</span>Player

<span style="color:#75715e"># We use the physics process function to track where the player is in the world</span>
<span style="color:#75715e"># and generate new sectors as they move away from existing ones.</span>
<span style="color:#66d9ef">func</span> _physics_process(_delta: <span style="color:#a6e22e">float</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#75715e"># Every frame, we compare the player&#39;s position to the current sector. If</span>
    <span style="color:#75715e"># they move far enough from it, we need to update the world.</span>
    <span style="color:#66d9ef">var</span> sector_location :<span style="color:#f92672">=</span> _current_sector <span style="color:#f92672">*</span> sector_size
    <span style="color:#66d9ef">if</span> _player<span style="color:#f92672">.</span>global_position<span style="color:#f92672">.</span>distance_squared_to(sector_location) <span style="color:#f92672">&gt;</span> _total_sector_count:
        <span style="color:#75715e"># Our function to update the sectors takes a vector to offset. As the</span>
        <span style="color:#75715e"># _player can be moving left, right, up, or down, we store that</span>
        <span style="color:#75715e"># information in our sector_offset variable.</span>
        <span style="color:#66d9ef">var</span> sector_offset :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>ZERO
        sector_offset <span style="color:#f92672">=</span> (_player<span style="color:#f92672">.</span>global_position <span style="color:#f92672">-</span> sector_location) <span style="color:#f92672">/</span> sector_size
        sector_offset<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> <span style="color:#a6e22e">int</span>(sector_offset<span style="color:#f92672">.</span>x)
        sector_offset<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> <span style="color:#a6e22e">int</span>(sector_offset<span style="color:#f92672">.</span>y)

        _update_sectors(sector_offset)
        <span style="color:#75715e"># We also update the grid position to encompass the active sectors. We</span>
        <span style="color:#75715e"># don&#39;t need to redraw the grid, so we move it using the provided</span>
        <span style="color:#75715e"># function.</span>
        _grid_drawer<span style="color:#f92672">.</span>move_grid_to(_current_sector)
</pre>
<p>Above, we calculated the squared distance between the player’s position and the sector. Doing so is faster than using the <code>Vector2.distance_to()</code> method.</p>
<p>This is because the distance between two points <code>a</code> and <code>b</code> is <code>sqrt(pow(b.x - a.x, 2) + pow(b.y - a.y, 2))</code>. Calculating the square root of a number is computationally intensive. If we calculate the squared distance, we remove the square root, and the calculation becomes much faster. It may not matter in a small game, but if you need to calculate distances often, you’ll want to compare squared distances.</p>
<p>With those changes, if you try the game again and keep moving, you will notice that new sectors keep appearing: the world never ends.</p>
<p>With that, you already have your first infinite world, even though it’s a bit simple. But you have the foundations in place already and can build upon them.</p>
<p>In the next part, we’ll work on the blue noise generator.</p>
<h2 id="code-reference">Code reference</h2>
<p>Here are the complete <code>WorldGenerator</code> and <code>WhiteNoiseWorldGenerator</code> scripts.</p>
<p>Starting with <code>WorldGenerator.gd</code>.</p>
<pre style="color:#f8f8f2;background-color:#272822">class_name WorldGenerator
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node2D</span>

<span style="color:#66d9ef">enum</span> { AXIS_X, AXIS_Y }

<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> sector_size :<span style="color:#f92672">=</span> <span style="color:#ae81ff">1000.0</span>
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> sector_axis_count :<span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> start_seed :<span style="color:#f92672">=</span> <span style="color:#e6db74">&quot;world_generation&quot;</span>

<span style="color:#66d9ef">var</span> _sectors :<span style="color:#f92672">=</span> {}
<span style="color:#66d9ef">var</span> _current_sector :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>ZERO
<span style="color:#66d9ef">var</span> _rng :<span style="color:#f92672">=</span> RandomNumberGenerator<span style="color:#f92672">.</span>new()

<span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> _half_sector_size :<span style="color:#f92672">=</span> sector_size <span style="color:#f92672">/</span> <span style="color:#ae81ff">2.0</span>
<span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> _total_sector_count :<span style="color:#f92672">=</span> sector_size <span style="color:#f92672">*</span> sector_size
<span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> _half_sector_count :<span style="color:#f92672">=</span> <span style="color:#a6e22e">int</span>(sector_axis_count <span style="color:#f92672">/</span> <span style="color:#ae81ff">2.0</span>)


<span style="color:#66d9ef">func</span> generate() <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#f92672">-</span>_half_sector_count, _half_sector_count):
        <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(<span style="color:#f92672">-</span>_half_sector_count, _half_sector_count):
            _generate_sector(x, y)


<span style="color:#66d9ef">func</span> _generate_sector(_x_id: <span style="color:#a6e22e">int</span>, _y_id: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">pass</span>


<span style="color:#66d9ef">func</span> make_seed_for(_x_id: <span style="color:#a6e22e">int</span>, _y_id: <span style="color:#a6e22e">int</span>, custom_data :<span style="color:#f92672">=</span> <span style="color:#e6db74">&quot;&quot;</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">int</span>:
    <span style="color:#66d9ef">var</span> new_seed :<span style="color:#f92672">=</span> <span style="color:#e6db74">&quot;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">_</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">_</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&quot;</span> <span style="color:#f92672">%</span> [start_seed, _x_id, _y_id]
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> custom_data<span style="color:#f92672">.</span>empty():
        new_seed <span style="color:#f92672">=</span> <span style="color:#e6db74">&quot;</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">_</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&quot;</span> <span style="color:#f92672">%</span> [new_seed, custom_data]
    <span style="color:#66d9ef">return</span> new_seed<span style="color:#f92672">.</span>hash()


<span style="color:#66d9ef">func</span> _update_sectors(difference: <span style="color:#a6e22e">Vector2</span>) <span style="color:#f92672">-&gt;</span> void:
    _update_along_axis(AXIS_X, difference<span style="color:#f92672">.</span>x)
    _update_along_axis(AXIS_Y, difference<span style="color:#f92672">.</span>y)


<span style="color:#66d9ef">func</span> _update_along_axis(axis: <span style="color:#a6e22e">int</span>, difference: <span style="color:#a6e22e">float</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">if</span> difference <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> (axis <span style="color:#f92672">!=</span> AXIS_X <span style="color:#f92672">and</span> axis <span style="color:#f92672">!=</span> AXIS_Y):
        <span style="color:#66d9ef">return</span>

    <span style="color:#66d9ef">var</span> axis_modifier :<span style="color:#f92672">=</span> <span style="color:#a6e22e">int</span>(difference <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
    <span style="color:#66d9ef">var</span> sector_axis_coordinate :<span style="color:#f92672">=</span> _current_sector<span style="color:#f92672">.</span>x <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> _current_sector<span style="color:#f92672">.</span>y
    <span style="color:#66d9ef">var</span> new_sector_line_index :<span style="color:#f92672">=</span> <span style="color:#a6e22e">int</span>(
        sector_axis_coordinate <span style="color:#f92672">+</span> (_half_sector_count <span style="color:#f92672">-</span> axis_modifier) <span style="color:#f92672">*</span> difference <span style="color:#f92672">+</span> difference
    )

    <span style="color:#66d9ef">var</span> other_axis_position :<span style="color:#f92672">=</span> _current_sector<span style="color:#f92672">.</span>y <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> _current_sector<span style="color:#f92672">.</span>x
    <span style="color:#66d9ef">var</span> other_axis_min :<span style="color:#f92672">=</span> other_axis_position <span style="color:#f92672">-</span> _half_sector_count
    <span style="color:#66d9ef">var</span> other_axis_max :<span style="color:#f92672">=</span> other_axis_position <span style="color:#f92672">+</span> _half_sector_count

    <span style="color:#66d9ef">for</span> other_axis_coordinate <span style="color:#f92672">in</span> range(other_axis_min, other_axis_max):
        <span style="color:#66d9ef">var</span> x :<span style="color:#f92672">=</span> new_sector_line_index <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> other_axis_coordinate
        <span style="color:#66d9ef">var</span> y :<span style="color:#f92672">=</span> other_axis_coordinate <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> new_sector_line_index
        _generate_sector(x, y)

    <span style="color:#66d9ef">var</span> obsolete_sector_line_index :<span style="color:#f92672">=</span> <span style="color:#a6e22e">int</span>(new_sector_line_index <span style="color:#f92672">+</span> sector_axis_count <span style="color:#f92672">*</span> <span style="color:#f92672">-</span>difference)

    <span style="color:#66d9ef">for</span> other_axis_coordinate <span style="color:#f92672">in</span> range(other_axis_min, other_axis_max):
        <span style="color:#66d9ef">var</span> key :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(
            obsolete_sector_line_index <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> other_axis_coordinate,
            other_axis_coordinate <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X <span style="color:#66d9ef">else</span> obsolete_sector_line_index
        )

        <span style="color:#66d9ef">if</span> _sectors<span style="color:#f92672">.</span>has(key):
            <span style="color:#66d9ef">var</span> sector_data: <span style="color:#a6e22e">Array</span> <span style="color:#f92672">=</span> _sectors[key]
            <span style="color:#66d9ef">for</span> d <span style="color:#f92672">in</span> sector_data:
                d<span style="color:#f92672">.</span>queue_free()
            <span style="color:#66d9ef">var</span> _found :<span style="color:#f92672">=</span> _sectors<span style="color:#f92672">.</span>erase(key)

    <span style="color:#66d9ef">if</span> axis <span style="color:#f92672">==</span> AXIS_X:
        _current_sector<span style="color:#f92672">.</span>x <span style="color:#f92672">+=</span> difference
    <span style="color:#66d9ef">else</span>:
        _current_sector<span style="color:#f92672">.</span>y <span style="color:#f92672">+=</span> difference
</pre>
<p>And <code>WhiteNoiseWorldGenerator.gd</code>.</p>
<pre style="color:#f8f8f2;background-color:#272822">class_name WhiteNoiseWorldGenerator
<span style="color:#66d9ef">extends</span> WorldGenerator

<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> Asteroid: <span style="color:#a6e22e">PackedScene</span>
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> asteroid_density :<span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>

<span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> _grid_drawer :<span style="color:#f92672">=</span> <span style="color:#f92672">$</span>GridDrawer
<span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> _player :<span style="color:#f92672">=</span> <span style="color:#f92672">$</span>Player


<span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
    generate()
    _grid_drawer<span style="color:#f92672">.</span>setup(sector_size, sector_axis_count)


<span style="color:#66d9ef">func</span> _physics_process(_delta: <span style="color:#a6e22e">float</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">var</span> sector_location :<span style="color:#f92672">=</span> _current_sector <span style="color:#f92672">*</span> sector_size
    <span style="color:#66d9ef">if</span> _player<span style="color:#f92672">.</span>global_position<span style="color:#f92672">.</span>distance_squared_to(sector_location) <span style="color:#f92672">&gt;</span> _total_sector_count:
        <span style="color:#66d9ef">var</span> sector_offset :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>ZERO
        sector_offset <span style="color:#f92672">=</span> (_player<span style="color:#f92672">.</span>global_position <span style="color:#f92672">-</span> sector_location) <span style="color:#f92672">/</span> sector_size
        sector_offset<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> <span style="color:#a6e22e">int</span>(sector_offset<span style="color:#f92672">.</span>x)
        sector_offset<span style="color:#f92672">.</span>y <span style="color:#f92672">=</span> <span style="color:#a6e22e">int</span>(sector_offset<span style="color:#f92672">.</span>y)

        _update_sectors(sector_offset)
        _grid_drawer<span style="color:#f92672">.</span>move_grid_to(_current_sector)


<span style="color:#66d9ef">func</span> _generate_sector(x_id: <span style="color:#a6e22e">int</span>, y_id: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> void:
    _rng<span style="color:#f92672">.</span>seed <span style="color:#f92672">=</span> make_seed_for(x_id, y_id)

    <span style="color:#66d9ef">var</span> sector_data :<span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> _i <span style="color:#f92672">in</span> range(asteroid_density):
        <span style="color:#66d9ef">var</span> asteroid :<span style="color:#f92672">=</span> Asteroid<span style="color:#f92672">.</span>instance()
        add_child(asteroid)

        asteroid<span style="color:#f92672">.</span>position <span style="color:#f92672">=</span> _generate_random_position(x_id, y_id)
        asteroid<span style="color:#f92672">.</span>rotation <span style="color:#f92672">=</span> _rng<span style="color:#f92672">.</span>randf_range(<span style="color:#f92672">-</span>PI, PI)
        asteroid<span style="color:#f92672">.</span>scale <span style="color:#f92672">*=</span> _rng<span style="color:#f92672">.</span>randf_range(<span style="color:#ae81ff">0.2</span>, <span style="color:#ae81ff">1.0</span>)
        sector_data<span style="color:#f92672">.</span>append(asteroid)

    _sectors[<span style="color:#a6e22e">Vector2</span>(x_id, y_id)] <span style="color:#f92672">=</span> sector_data


<span style="color:#66d9ef">func</span> _generate_random_position(x_id: <span style="color:#a6e22e">int</span>, y_id: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">Vector2</span>:
    <span style="color:#66d9ef">var</span> sector_position <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(x_id <span style="color:#f92672">*</span> sector_size, y_id <span style="color:#f92672">*</span> sector_size)
    <span style="color:#66d9ef">var</span> sector_top_left <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(
        sector_position<span style="color:#f92672">.</span>x <span style="color:#f92672">-</span> _half_sector_size, sector_position<span style="color:#f92672">.</span>y <span style="color:#f92672">-</span> _half_sector_size
    )
    <span style="color:#66d9ef">var</span> sector_bottom_right <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(
        sector_position<span style="color:#f92672">.</span>x <span style="color:#f92672">+</span> _half_sector_size, sector_position<span style="color:#f92672">.</span>y <span style="color:#f92672">+</span> _half_sector_size
    )

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Vector2</span>(
        _rng<span style="color:#f92672">.</span>randf_range(sector_top_left<span style="color:#f92672">.</span>x, sector_bottom_right<span style="color:#f92672">.</span>x),
        _rng<span style="color:#f92672">.</span>randf_range(sector_top_left<span style="color:#f92672">.</span>y, sector_bottom_right<span style="color:#f92672">.</span>y)
    )
</pre>
</body>
</html>
