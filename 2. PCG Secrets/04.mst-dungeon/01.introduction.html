<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>TmpX9yvYcIkjj</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <style type="text/css">:root {--c-caption: grey;--c-blue: #26bfe3;--c-green: #02e180;--c-orange: #f2971a;--c-pink: #e3266f;--c-bg: #fff;--c-bg-alt: #f5f5f5;--c-text-header: #fff;--c-text-body: #95989a;--padding: 20px;--padding-inv: calc(-1 * var(--padding));--fonts: "Open Sans", -apple-system, system-ui, "Segoe UI", "Roboto","Helvetica Neue", Arial, sans-serif;--font-size: 1.1rem;}html {font-size: 100%;}body {color: #444;font-family: var(--fonts);font-size: var(--font-size);line-height: 1.7;padding: 1em;margin: auto;max-width: 800px;background: #fefefe;}a {color: #0645ad;text-decoration: none;}a:visited {color: #0b0080;}a:hover {color: #06e;}a:active {color: #faa700;}a:focus {outline: thin dotted;}a::selection {background: rgba(255, 255, 0, 0.3);color: #0645ad;}*::selection {background: rgba(255, 255, 0, 0.3);color: #000;}p {margin: 1em 0;}.caption {text-align: center;color: var(--c-caption);font-style: italic;}.note,.tips,.warning {display: block;width: calc(100% - var(--padding) * 2);padding: 0 var(--padding);padding-bottom: var(--padding);background-color: var(--c-bg-alt);}.note:before,.tips:before,.warning:before {display: block;margin: 0 var(--padding-inv) 10px var(--padding-inv);padding-left: var(--padding);font-style: bold;color: white;}.note:before {content: "Note";background-color: var(--c-blue);}.tips:before {content: "Tips";background-color: var(--c-pink);}.warning:before {content: "Warning";background-color: var(--c-orange);}img {max-width: 100%;}h1,h2,h3,h4,h5,h6 {color: #111;line-height: 125%;margin-top: 2em;font-weight: normal;}h4,h5,h6 {font-weight: bold;}h1 {font-size: 2.5em;}h2 {font-size: 2em;}h3 {font-size: 1.5em;}h4 {font-size: 1.2em;}blockquote {color: #666666;margin: 0;padding-left: 3em;border-left: 0.5em #eee solid;}hr {display: block;height: 2px;border: 0;border-top: 1px solid #aaa;border-bottom: 1px solid #eee;margin: 1em 0;padding: 0;}pre,code,kbd,samp {color: #0084b8;font-family: monospace, monospace;}pre {background-color: #f9f9f9;padding: 1em;font-size: 14px;white-space: pre-wrap;word-wrap: break-word;}code {white-space: pre-wrap;}b,strong {font-weight: bold;}dfn {font-style: italic;color: var(--c-blue);}ins {background: #ff9;color: #000;text-decoration: none;}ul,ol {margin: 1em 0;padding: 0 0 0 2em;}li p:last-child {margin-bottom: 0;}ul ul,ol ol {margin: 0.3em 0;}dl {margin-bottom: 1em;}dt {font-weight: bold;margin-bottom: 0.8em;}dd {margin: 0 0 0.8em 2em;}dd:last-child {margin-bottom: 0;}img {border: 0;-ms-interpolation-mode: bicubic;vertical-align: middle;}figure {display: block;text-align: center;margin: 1em 0;}figure img {border: none;margin: 0 auto;}figcaption {font-size: 0.8em;font-style: italic;margin: 0 0 0.8em;}.author {font-size: 1.2em;text-align: center;}tag {min-width: 3.2em;text-align: center;border-radius: 8px;padding: 0 4px;margin-bottom: 0;margin-top: 4px;margin-right: 0.2em;display: inline-block;color: white;}tag.update {background: var(--c-blue);}tag.new {background: var(--c-green);}tag.update:after {content: "update";}tag.new:after {content: "new";}button {background-color: var(--c-blue);color: white;border: none;cursor: pointer;line-height: 2rem;font-size: 1.2rem;margin: 0.75rem 0;overflow: visible;padding: 0.75rem 1.5rem;border-radius: 1rem;transition: background-color $transition-duration;white-space: nowrap;}</style>
</head>
<body>
<h1 id="a-dungeon-generator-based-on-physics-and-minimum-spanning-trees">A Dungeon Generator based on Physics and Minimum Spanning Trees</h1>
<p>When we think of procedural content generators (PCG) for levels, we usually think of mathematics, random numbers, and computations. They are the main ingredients to build variations within our games. One other approach that we use less often is physics-based simulation.</p>
<p>In this tutorial, we’re going to create a dungeon using Godot’s physics engine that’s more refined than what we made in the first chapter.</p>
<p>Here is how our final product looks.</p>
<figure>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAJ9AQMAAACRv5LlAAAABlBMVEUyKUf//+s8o8D3AAAACXBIWXMAAA7EAAAOxAGVKw4bAAACLElEQVR42u3cMW7CMBQGYKMMjD0CR8nR2qMh9SI9AmMHlFe1siglUFDSYhx//+Y48vsGD8mLlRSFkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmL5CzBgAAAAAAAAAAAAAAaAjw8qMiAABAw4CTAAAAAAAAAAAAALQD2KUE0Drg7CbcTG/xAAAAAAAAAAAAAAAAVAg4JwAAAAAAAAAAKAFYR+xz+T4CAAAAAAAAAAAAAACgcUDxVzMAAIBS34w6AAAAAAAAAAAAAAAAgBhmd2gA6gakP+jSAVQHGI4Ll9iEAAAAAAAAAAAAAAAADwF4ji0AAABA2TZdAAAANAz4PkU7bL4uvOULKwAAAAAAAACAOwMOf6cd7nyIBQAAAAAAAAAAAKA6wHBDFxEAAAAAAAAAYAbg+n9KAZYOWMfrAABQA+CQFQAAAABA9YD30XNQd1LiZBIAAAAAAAAAYMGAPo8BAAAaBRyNfwWMAtAcoPgmBAAAAOjybVuA5QByr/g6oM+TAAAAAAAAAAD/D0irEeBYBwDwIIArAagL8JkdAAAAwKMAxpX3fUwIAAAAAAAAAAAAAAAAAECFgMtnJgAaAcTFTThxHQAAgCUAupgRAAAAgNmAp5gXAAAAgBSFAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AHz1GA6QN1j9AAAAABJRU5ErkJggg==" alt />
</figure>
<p>Unlike in the first chapter, rooms can clump together with this algorithm, creating large open spaces. We keep the rooms that overlap with the corridors to create this thick look.</p>
<p class="note">
We use the cream color (<code>#ffffeb</code>) from the <a href="https://lospec.com/palette-list/pear36">Pear36</a> palette as our background because our tileset uses a dark purple that doesn’t go well with the default gray. You can change this color by going to the menu <em>Project &gt; Project Settings &gt; Rendering &gt; Environment</em>.
</p>
<p>In this chapter, you will learn advanced concepts such as:</p>
<ul>
<li>Manipulating <code>RigidBody2D</code> and controlling its rest state.</li>
<li>Calculating a graph of required connections between rooms.</li>
<li>Understanding and using <code>AStar2D</code>.</li>
<li>Animating in real-time using <code>TileMap</code> so you can visualize the algorithm at work.</li>
<li>Using signals to coordinate the game execution.</li>
</ul>
<h2 id="get-the-demo-project">Get the demo project</h2>
<p>This chapter’s associated directory, in our <a href="https://github.com/GDQuest/godot-procedural-generation">Procedural Generation</a> demos project, is <code>MSTDungeon</code>. The implementation from the final demo project is slightly different from the one you will code here. It provides visual feedback for the Minimum Spanning Tree graph and the final room graph as well.</p>
<p class="note">
All classes related to this algorithm have a <code>class_name</code> that starts with <code>MSTDungeon</code> to prevent conflicts in class name registrations by Godot.
</p>
<h2 id="preparing-the-project">Preparing the project</h2>
<p>Open a new project in Godot if you haven’t done so yet and copy the <code>Common</code> folder from our <a href="https://github.com/GDQuest/godot-procedural-generation">Procedural Generation</a> demos project. Likewise, you can copy the <code>MSTDungeon</code> folder in case you want to compare your work and the final implementation easily.</p>
<h2 id="brief-overview-of-the-algorithm">Brief overview of the algorithm</h2>
<p>The steps to generating the dungeon are:</p>
<ol type="1">
<li>Create the <code>RigidBody2D</code> rooms by modifying how the physics object works for our needs.</li>
<li>Randomly place the rooms in a circular pattern, clustered together.</li>
<li>Start the physics simulation and wait to stabilize, that is to say until there are no collision detections and rooms are non-overlapping.</li>
<li>Select the main rooms for the next step, based on the average room size.</li>
<li>Compute the <a href="https://en.wikipedia.org/wiki/Minimum_spanning_tree">minimum spanning tree (MST)</a> graph for main rooms. We’ll use <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim’s algorithm</a> for this.</li>
<li>Read a few more edges to the MST graph so that the player doesn’t have to backtrack too much between dead ends.</li>
<li>Connect rooms with corridors and complete the level.</li>
</ol>
<h2 id="references">References</h2>
<p>This tutorial is based on work from:</p>
<ul>
<li><a href="https://www.gamasutra.com/blogs/AAdonaac/20150903/252889/Procedural_Dungeon_Generation_Algorithm.php">Procedural Dungeon Generation Algorithm</a>. This is a Unity tutorial that explores this concept in an overview format.</li>
<li><a href="https://www.youtube.com/playlist?list=PLsk-HSGFjnaH82Bn6xbQNehatj3sIvtMQ">Procedural Generation in Godot</a>. This playlist contains a mini-tutorial series exploring the same concept by <a href="https://www.youtube.com/channel/UCNaPQ5uLX5iIEHUCLmfAgKg">KidsCanCode</a>.</li>
</ul>
</body>
</html>
