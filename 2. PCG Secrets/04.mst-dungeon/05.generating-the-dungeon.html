<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>TmpAXyOQpmVi5</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <style type="text/css">:root {--c-caption: grey;--c-blue: #26bfe3;--c-green: #02e180;--c-orange: #f2971a;--c-pink: #e3266f;--c-bg: #fff;--c-bg-alt: #f5f5f5;--c-text-header: #fff;--c-text-body: #95989a;--padding: 20px;--padding-inv: calc(-1 * var(--padding));--fonts: "Open Sans", -apple-system, system-ui, "Segoe UI", "Roboto","Helvetica Neue", Arial, sans-serif;--font-size: 1.1rem;}html {font-size: 100%;}body {color: #444;font-family: var(--fonts);font-size: var(--font-size);line-height: 1.7;padding: 1em;margin: auto;max-width: 800px;background: #fefefe;}a {color: #0645ad;text-decoration: none;}a:visited {color: #0b0080;}a:hover {color: #06e;}a:active {color: #faa700;}a:focus {outline: thin dotted;}a::selection {background: rgba(255, 255, 0, 0.3);color: #0645ad;}*::selection {background: rgba(255, 255, 0, 0.3);color: #000;}p {margin: 1em 0;}.caption {text-align: center;color: var(--c-caption);font-style: italic;}.note,.tips,.warning {display: block;width: calc(100% - var(--padding) * 2);padding: 0 var(--padding);padding-bottom: var(--padding);background-color: var(--c-bg-alt);}.note:before,.tips:before,.warning:before {display: block;margin: 0 var(--padding-inv) 10px var(--padding-inv);padding-left: var(--padding);font-style: bold;color: white;}.note:before {content: "Note";background-color: var(--c-blue);}.tips:before {content: "Tips";background-color: var(--c-pink);}.warning:before {content: "Warning";background-color: var(--c-orange);}img {max-width: 100%;}h1,h2,h3,h4,h5,h6 {color: #111;line-height: 125%;margin-top: 2em;font-weight: normal;}h4,h5,h6 {font-weight: bold;}h1 {font-size: 2.5em;}h2 {font-size: 2em;}h3 {font-size: 1.5em;}h4 {font-size: 1.2em;}blockquote {color: #666666;margin: 0;padding-left: 3em;border-left: 0.5em #eee solid;}hr {display: block;height: 2px;border: 0;border-top: 1px solid #aaa;border-bottom: 1px solid #eee;margin: 1em 0;padding: 0;}pre,code,kbd,samp {color: #0084b8;font-family: monospace, monospace;}pre {background-color: #f9f9f9;padding: 1em;font-size: 14px;white-space: pre-wrap;word-wrap: break-word;}code {white-space: pre-wrap;}b,strong {font-weight: bold;}dfn {font-style: italic;color: var(--c-blue);}ins {background: #ff9;color: #000;text-decoration: none;}ul,ol {margin: 1em 0;padding: 0 0 0 2em;}li p:last-child {margin-bottom: 0;}ul ul,ol ol {margin: 0.3em 0;}dl {margin-bottom: 1em;}dt {font-weight: bold;margin-bottom: 0.8em;}dd {margin: 0 0 0.8em 2em;}dd:last-child {margin-bottom: 0;}img {border: 0;-ms-interpolation-mode: bicubic;vertical-align: middle;}figure {display: block;text-align: center;margin: 1em 0;}figure img {border: none;margin: 0 auto;}figcaption {font-size: 0.8em;font-style: italic;margin: 0 0 0.8em;}.author {font-size: 1.2em;text-align: center;}tag {min-width: 3.2em;text-align: center;border-radius: 8px;padding: 0 4px;margin-bottom: 0;margin-top: 4px;margin-right: 0.2em;display: inline-block;color: white;}tag.update {background: var(--c-blue);}tag.new {background: var(--c-green);}tag.update:after {content: "update";}tag.new:after {content: "new";}button {background-color: var(--c-blue);color: white;border: none;cursor: pointer;line-height: 2rem;font-size: 1.2rem;margin: 0.75rem 0;overflow: visible;padding: 0.75rem 1.5rem;border-radius: 1rem;transition: background-color $transition-duration;white-space: nowrap;}</style>
</head>
<body>
<h1 id="simulating-and-generating-the-dungeon">Simulating and generating the dungeon</h1>
<p>It’s now time to implement the physics simulation of our dungeon. We’re also going to draw on tile-map in real-time to visualize the dungeon building up.</p>
<p>We start by defining the <code>_ready()</code> function which randomizes the <code>RandomNumberGenerator</code>. That way, we get a different result each time we run the project. Then, it delegates the work to the <code>_generate()</code> function.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
    _rng<span style="color:#f92672">.</span>randomize()
    _generate()
</pre>
<p>Let’s take a look at the <code>_generate()</code> function next.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># Places the rooms and starts the physics simulation. Once the simulation is done</span>
<span style="color:#75715e"># (&quot;rooms_placed&quot; gets emitted), it continues by assigning tiles in the Level node.</span>
<span style="color:#66d9ef">func</span> _generate() <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#75715e"># Generate `max_rooms` rooms and set them up</span>
    <span style="color:#66d9ef">for</span> _i <span style="color:#f92672">in</span> range(max_rooms):
        <span style="color:#66d9ef">var</span> room :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Room</span><span style="color:#f92672">.</span>instance()
        room<span style="color:#f92672">.</span>connect(<span style="color:#e6db74">&quot;sleeping_state_changed&quot;</span>, self, <span style="color:#e6db74">&quot;_on_Room_sleeping_state_changed&quot;</span>)
        room<span style="color:#f92672">.</span>setup(_rng, level)
        rooms<span style="color:#f92672">.</span>add_child(room)

        _mean_room_size <span style="color:#f92672">+=</span> room<span style="color:#f92672">.</span>size
    _mean_room_size <span style="color:#f92672">/=</span> rooms<span style="color:#f92672">.</span>get_child_count()

    <span style="color:#75715e"># Wait for all rooms to be positioned in the game world.</span>
    yield(self, <span style="color:#e6db74">&quot;rooms_placed&quot;</span>)

    rooms<span style="color:#f92672">.</span>queue_free()
    <span style="color:#75715e"># Draws the tiles on the `level` tilemap.</span>
    level<span style="color:#f92672">.</span>clear()
    <span style="color:#66d9ef">for</span> point <span style="color:#f92672">in</span> _data:
        level<span style="color:#f92672">.</span>set_cellv(point, <span style="color:#ae81ff">0</span>)
</pre>
<p>As we mentioned before, we need to coordinate execution because the physics simulation will take time to stabilize. In the first part of the function, we instantiate the rooms and add them under the <em>Room</em> node to group them. We connect the <code>sleeping_state_changed</code> signal of each room to the <code>_on_Room_sleeping_state_changed()</code> function and set it up.</p>
<p>As we loop over <code>range(max_rooms)</code>, we can accumulate the sum of all room sizes and calculate the mean size: <code>_mean_room_size /= rooms.get_child_count()</code>.</p>
<p>If we were to freeze the game at this stage, we’d get the following picture.</p>
<figure>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAJ9BAMAAABZXx2VAAAAFVBMVEX//+sBmLEZYX0MfZgGi6UyKUd/zM+EJdeOAAAFA0lEQVR42u3du47bVhQFUDdOT/giHyAh6WcouD8QkdowoD5u9P+fEPFlyWN5dKk0yblrYRrPuCK39rl86sMHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIB/7+Ppuy+2hgAgADQWgN3qz7PNIQAIAAJAE6u+2e7q+kvbSQDI3fn7/mfXKPxtQwkADQfgj9Ppi20lAAgA2QMwDLEahuPyy1enBRoKQOli/ClFAFoJwH647PZFdzVlYHJ8FYDkAYiYP/jRxTUBMQhAaw1wu/81QFMNsOz0rvtxCMxrAQFI3wDdPAK6H02TQQAaaoB7BKDdAMS4KigC0MII0AAa4Bcu68Bj//LNxmo1AJdl4LH//LuNpQFocg1QukEA8gZg37+799cGCAHIG4Ao7yfAGiDv7j/NDVAedcBlSLgknDYA8WD3j6cCBCBlAL7udodhvAkgNEBTH/vVFIDukRCA1AEoDxNgBKQOQDxsgBCATAG4efxv3/cRjwvACEgZgL7vD0PNAAgjIG0ASsX+1wB5A/ASNfvfUUDiBuiqGAFpG6BUTQAN0HYDCEDbawAjIGkAhiEqC0ADZA1A5SJQAJpuAAHIGwBrAA2gARoMwPRCkKFUrgAEIGMAqu4DcB4gcwDuPA7+zoFg6QWg2QaYF4I3b46zFXMEIOp3f0wBWCNgK7bWANGFADS8BlhHgAAkCcCh/hzQek+IACQLwNY1YBGAZAHY1P8aoPERYA2QKADjwwBl6wBwFJArAJs//xogTwAO9VcBb94RYRGYKQBdbBsBxQhovAHG2wIFIFMDbJ4BGiBXAzyxChCAlhvAmcC21wBGQLYGMAI0gBFgDWAEOAowAppsgCdMrwoTgCQN8MTFoE4A2m4AAcjUAMUIaLwBigZoOQCDNUDrI0ADOAp44p6AIgAJAjA9FvTMPSHjySAB+P87n8/jfaHPHAV0HhDPE4DYfDVoGP4SgHYDMDZACEAO4zeFbE1AaIBcAdj4dGgUDZCtAYoGaLwBytb7AT4LQK41QNl4P4gApArAlmVgEYCMi8DQAA4DBaDhEVCqrwoKQNbzANXfGiQA+UZAVN8eXubrgN4WnKkBxp1fmwABSNkAZX4LrAA0ugYoXVf/rVECkPEwsPpkoACkPAqI2gYoApD3RJA1QMNrgOo3xgtA3gaouh382AtAwgaIYfx59GKIS0vEJwFI2ACxzIB499PfjRcNNEDCBpj2bLy5LeD6zyUeUwKKBkjZAPHzFcE31wfLQgBy+e08nwdYCv7mWOB7I6wDYgqIEZDOaT8+Jb647PMhxsPCUvrlydE5GbH+DwFIF4D5C6Rn1ygc+/nbhGLtfgFoIQBXr9OXCh6mPf6GAKRbB9x3PwAv3+a/2m75u+Hr7g6ffQFAABAABAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4L/kHIMYBwxsF05cAAAAASUVORK5CYII=" alt />
</figure>
<p>All rooms are stacked in the center, and positioned randomly inside a circle. The <code>Room</code> class takes care of this positioning.</p>
<p>We wait for the <code>rooms_placed</code> signal to be emitted which means that our <code>_data</code> dictionary is available for processing. We then remove the <em>Rooms</em> node since we don’t need it anymore. The last lines draw tiles in the tilemap.</p>
<h2 id="the-bulk-of-the-work">The bulk of the work</h2>
<p>The <code>_on_Room_sleeping_state_changed()</code> function does most of the work. It’s called each time a room stabilizes and its mode changes to <code>RigidBody2D.MODE_STATIC</code>. Before covering it, let’s go over the functions on which it depends.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#66d9ef">func</span> _is_main_room(room: <span style="color:#a6e22e">Room</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
    <span style="color:#66d9ef">return</span> room<span style="color:#f92672">.</span>size<span style="color:#f92672">.</span>x <span style="color:#f92672">&gt;</span> _mean_room_size<span style="color:#f92672">.</span>x <span style="color:#f92672">and</span> room<span style="color:#f92672">.</span>size<span style="color:#f92672">.</span>y <span style="color:#f92672">&gt;</span> _mean_room_size<span style="color:#f92672">.</span>y
</pre>
<p>The <code>_is_main_room()</code> function returns true if the room has a greater width and height than <code>_mean_room_size</code>.</p>
<p>The next function uses the room as an iterator. It loops over a room’s tile positions using a for loop and stores each <code>offset</code> in the <code>_data</code> dictionary.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># Adds room tile positions to `_data`.</span>
<span style="color:#66d9ef">func</span> _add_room(room: <span style="color:#a6e22e">Room</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">for</span> offset <span style="color:#f92672">in</span> room:
        _data[offset] <span style="color:#f92672">=</span> null
</pre>
<p>We’re left with <code>_add_corridors()</code> and <code>_add_corridor()</code>.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># Adds both secondary room and corridor tile positions to `_data`. Secondary rooms are the ones</span>
<span style="color:#75715e"># intersecting the corridors.</span>
<span style="color:#66d9ef">func</span> _add_corridors():
    <span style="color:#75715e"># Stores existing connections in its keys.</span>
    <span style="color:#66d9ef">var</span> connected :<span style="color:#f92672">=</span> {}

    <span style="color:#75715e"># Checks if points are connected by a corridor. If not, adds a corridor.</span>
    <span style="color:#66d9ef">for</span> point1_id <span style="color:#f92672">in</span> _path<span style="color:#f92672">.</span>get_points():
        <span style="color:#66d9ef">for</span> point2_id <span style="color:#f92672">in</span> _path<span style="color:#f92672">.</span>get_point_connections(point1_id):
            <span style="color:#66d9ef">var</span> point1 :<span style="color:#f92672">=</span> _path<span style="color:#f92672">.</span>get_point_position(point1_id)
            <span style="color:#66d9ef">var</span> point2 :<span style="color:#f92672">=</span> _path<span style="color:#f92672">.</span>get_point_position(point2_id)
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Vector2</span>(point1_id, point2_id) <span style="color:#f92672">in</span> connected:
                <span style="color:#66d9ef">continue</span>

            point1 <span style="color:#f92672">=</span> level<span style="color:#f92672">.</span>world_to_map(point1)
            point2 <span style="color:#f92672">=</span> level<span style="color:#f92672">.</span>world_to_map(point2)
            _add_corridor(point1<span style="color:#f92672">.</span>x, point2<span style="color:#f92672">.</span>x, point1<span style="color:#f92672">.</span>y, <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>AXIS_X)
            _add_corridor(point1<span style="color:#f92672">.</span>y, point2<span style="color:#f92672">.</span>y, point2<span style="color:#f92672">.</span>x, <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>AXIS_Y)

            <span style="color:#75715e"># Stores the connection between point 1 and 2.</span>
            connected[<span style="color:#a6e22e">Vector2</span>(point1_id, point2_id)] <span style="color:#f92672">=</span> null
            connected[<span style="color:#a6e22e">Vector2</span>(point2_id, point1_id)] <span style="color:#f92672">=</span> null
</pre>
<p>Before the loop we define the <code>connected</code> dictionary. We use it to store the pairs of points connected by a corridor. Since the graph we use is bidirectional, we might end up going from <code>point1</code> to <code>point2</code> and from <code>point2</code> to <code>point1</code>. To prevent this we define the <code>connected</code> dictionary.</p>
<p>For each point in the <code>AStar2D</code> graph, we get its connections with <code>AStar2D.get_point_connections()</code>, therefore we need the nested loop. Inside the loop, we get the positions of each pair of points and check to see if they’re connected by a corridor. If that’s the case, we then skip the rest of the code with <code>continue</code>. Otherwise, we run the rest of the loop which:</p>
<ol type="1">
<li>Converts the positions to map coordinates.</li>
<li>Adds the corridor by constructing a horizontal one, then a vertical one.</li>
<li>Records that the corridor was created between <code>point1</code> and <code>point2</code>.</li>
</ol>
<p>We have one last function to look at before moving to <code>_on_Room_sleeping_state_changed()</code>:</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># Adds a specific corridor (defined by the input parameters) to `_data`. It also adds all</span>
<span style="color:#75715e"># secondary rooms intersecting the corridor path.</span>
<span style="color:#66d9ef">func</span> _add_corridor(start: <span style="color:#a6e22e">int</span>, end: <span style="color:#a6e22e">int</span>, constant: <span style="color:#a6e22e">int</span>, axis: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">var</span> t :<span style="color:#f92672">=</span> min(start, end)
    <span style="color:#66d9ef">while</span> t <span style="color:#f92672">&lt;=</span> max(start, end):
        <span style="color:#66d9ef">var</span> point :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>ZERO
        match axis:
            <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>AXIS_X:
                point <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(t, constant)
            <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>AXIS_Y:
                point <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(constant, t)

        t <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">for</span> room <span style="color:#f92672">in</span> rooms<span style="color:#f92672">.</span>get_children():
            <span style="color:#66d9ef">if</span> _is_main_room(room):
                <span style="color:#66d9ef">continue</span>

            <span style="color:#66d9ef">var</span> top_left: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> level<span style="color:#f92672">.</span>world_to_map(room<span style="color:#f92672">.</span>position <span style="color:#f92672">-</span> room<span style="color:#f92672">.</span>size <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)
            <span style="color:#66d9ef">var</span> bottom_right: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> level<span style="color:#f92672">.</span>world_to_map(room<span style="color:#f92672">.</span>position <span style="color:#f92672">+</span> room<span style="color:#f92672">.</span>size <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)
            <span style="color:#66d9ef">if</span> (
                top_left<span style="color:#f92672">.</span>x <span style="color:#f92672">&lt;=</span> point<span style="color:#f92672">.</span>x
                <span style="color:#f92672">and</span> point<span style="color:#f92672">.</span>x <span style="color:#f92672">&lt;</span> bottom_right<span style="color:#f92672">.</span>x
                <span style="color:#f92672">and</span> top_left<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;=</span> point<span style="color:#f92672">.</span>y
                <span style="color:#f92672">and</span> point<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;</span> bottom_right<span style="color:#f92672">.</span>y
            ):
                _add_room(room)
                t <span style="color:#f92672">=</span> bottom_right[axis]
        _data[point] <span style="color:#f92672">=</span> null
</pre>
<p>This is similar to the function we saw in the first chapter, where we used <code>Vector2.AXIS_X</code> and <code>Vector2.AXIS_Y</code> to invert the parametrization of the line we need to traverse. Please refer to that chapter for details.</p>
<p>The rest of the code adds secondary rooms that intersect with the corridor while constructing it. The loop goes like this:</p>
<ol type="1">
<li>First only look at secondary rooms, that is for which <code>_is_main_room()</code> returns false.</li>
<li>Calculate the <code>top_left</code> and <code>bottom_right</code> corners of the room.</li>
<li>If <code>point</code>, the current corridor position, falls within the rectangle of the room then call <code>_add_room()</code> and move <code>t</code> at the end of the room.</li>
</ol>
<p>Before we exit the outer while loop, we add <code>point</code> to the <code>_data</code> dictionary to save the corridor current position.</p>
<p>Now we’re ready to tackle <code>_on_Room_sleeping_state_changed()</code>.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># Calld every time stabilizes (mode changes to RigidBody2D.MODE_STATIC).</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># Once all rooms have stabilized it calcualtes a playable dungeon `_path` using the MST</span>
<span style="color:#75715e"># algorithm. Based on the calculated `_path`, it populates `_data` with room and corridor tile</span>
<span style="color:#75715e"># positions.</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># It emits the &quot;rooms_placed&quot; signal when it finishes so we can begin the tileset placement.</span>
<span style="color:#66d9ef">func</span> _on_Room_sleeping_state_changed() <span style="color:#f92672">-&gt;</span> void:
    _sleeping_rooms <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">if</span> _sleeping_rooms <span style="color:#f92672">&lt;</span> max_rooms:
        <span style="color:#66d9ef">return</span>

    <span style="color:#66d9ef">var</span> main_rooms :<span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">var</span> main_rooms_positions :<span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> room <span style="color:#f92672">in</span> rooms<span style="color:#f92672">.</span>get_children():
        <span style="color:#66d9ef">if</span> _is_main_room(room):
            main_rooms<span style="color:#f92672">.</span>push_back(room)
            main_rooms_positions<span style="color:#f92672">.</span>push_back(room<span style="color:#f92672">.</span>position)

    _path <span style="color:#f92672">=</span> Utils<span style="color:#f92672">.</span>mst(main_rooms_positions)

    <span style="color:#66d9ef">for</span> point1_id <span style="color:#f92672">in</span> _path<span style="color:#f92672">.</span>get_points():
        <span style="color:#66d9ef">for</span> point2_id <span style="color:#f92672">in</span> _path<span style="color:#f92672">.</span>get_points():
            <span style="color:#66d9ef">if</span> (
                point1_id <span style="color:#f92672">!=</span> point2_id
                <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> _path<span style="color:#f92672">.</span>are_points_connected(point1_id, point2_id)
                <span style="color:#f92672">and</span> _rng<span style="color:#f92672">.</span>randf() <span style="color:#f92672">&lt;</span> reconnection_factor
            ):
                _path<span style="color:#f92672">.</span>connect_points(point1_id, point2_id)

    <span style="color:#66d9ef">for</span> room <span style="color:#f92672">in</span> main_rooms:
        _add_room(room)
    _add_corridors()

    set_process(false)
    emit_signal(<span style="color:#e6db74">&quot;rooms_placed&quot;</span>)
</pre>
<p>Each time a room changes mode to <code>RigidBody2D.MODE_STATIC</code>, we increase <code>_sleeping_rooms</code> by <code>1</code>. If <code>_sleeping_rooms &lt; max_rooms</code> is true, it means that there are still rooms that need to reach a stable position before moving on. So we return from the function without doing anything else if that happens. If the opposite is true and <code>_sleeping_rooms &gt;= max_rooms</code> then the rest of the function gets executed.</p>
<p>We start by creating two empty arrays: <code>main_rooms</code> and <code>main_rooms_positions</code>. We loop over all the available rooms and if <code>_is_main_room()</code> returns true, then we store that room and its position in these arrays. We then calculate the minimum spanning tree (MST) graph using <code>Utils.mst()</code>.</p>
<p>Before constructing the dungeon based on the MST graph, we restore a small fraction of extra graph connections. We do this to create cyclic connections so the player doesn’t have to always backtrack. The implementation goes over all the pairs of points in <code>_path</code> and if we:</p>
<ol type="1">
<li>Are not looking at the same point (<code>point1_id != point2_id</code>).</li>
<li>The points aren’t connected by an edge (<code>not _path.are_points_connected(point1_id, point2_id)</code>).</li>
<li>We successfully generate a random number smaller than <code>reconnection_factor</code>.</li>
</ol>
<p>Then we connect these points by an edge. Once we’re done with all of this we add only the main rooms that we previously saved and finally add the corridors. As you saw, when adding the corridors we also add extra secondary rooms along the way. So our dungeon will feature clusters of rooms along these corridors.</p>
<p>At the very end of the function we turn off processing and emit the <code>rooms_placed</code> signal so that <code>_generate()</code> continues with the rest of the code that visually constructs the dungeon from <code>_data</code>. You might be wondering why we turn of processing here as we haven’t implemented <code>_process()</code> yet. Read on to find out.</p>
<h2 id="real-time-dungeon-construction-feedback">Real-time dungeon construction feedback</h2>
<p>At this stage we don’t have any visual feedback during dungeon construction, unless we turn on <em>Debug &gt; Visible Collision Shapes</em>. We can fix this by implementing <code>_process()</code> so that we assign tiles based on rooms data:</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># This is for visual feedback. We just re-render the rooms every frame.</span>
<span style="color:#66d9ef">func</span> _process(delta: <span style="color:#a6e22e">float</span>) <span style="color:#f92672">-&gt;</span> void:
    level<span style="color:#f92672">.</span>clear()
    <span style="color:#66d9ef">for</span> room <span style="color:#f92672">in</span> rooms<span style="color:#f92672">.</span>get_children():
        <span style="color:#66d9ef">for</span> offset <span style="color:#f92672">in</span> room:
            level<span style="color:#f92672">.</span>set_cellv(offset, <span style="color:#ae81ff">0</span>)
</pre>
<p>Every frame we start by clearing the <code>level</code>. Next, for each room we iterate over it using our custom iterator once again and setting the appropriate <em>TileMap</em> position.</p>
<p>And with this we finished this tutorial. We hope you had a great time following along and we wish you the best of luck in implementing your own variations!</p>
<h2 id="references">References</h2>
<p>Below you can find the <em>MSTDungeon</em> generator full script.</p>
<pre style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e"># Generates a dungeon using RigidBody2D physics and Minimum Spanning Trees (MST).</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># The algorithm works like so:</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># 1. Spawns and spreads collision shapes around the game world using the physics engine.</span>
<span style="color:#75715e"># 2. Waits for the rooms to be in a more or less resting state.</span>
<span style="color:#75715e"># 3. Selects some main rooms for the level based on the average room size.</span>
<span style="color:#75715e"># 4. Creates a Minimum Spanning Tree graph that connects the rooms.</span>
<span style="color:#75715e"># 5. Adds back some connections after calculating the MST so the player doesn&#39;t need to backtrack.</span>
<span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">Node2D</span>


<span style="color:#75715e"># Emitted when all the rooms stabilized.</span>
<span style="color:#66d9ef">signal</span> rooms_placed

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">Room</span> :<span style="color:#f92672">=</span> preload(<span style="color:#e6db74">&quot;Room.tscn&quot;</span>)

<span style="color:#75715e"># Maximum number of generated rooms.</span>
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> max_rooms :<span style="color:#f92672">=</span> <span style="color:#ae81ff">60</span>
<span style="color:#75715e"># Controls the number of paths we add to the dungeon after generating it,</span>
<span style="color:#75715e"># limiting player backtracking.</span>
<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">var</span> reconnection_factor :<span style="color:#f92672">=</span> <span style="color:#ae81ff">0.025</span>

<span style="color:#66d9ef">var</span> _rng :<span style="color:#f92672">=</span> RandomNumberGenerator<span style="color:#f92672">.</span>new()
<span style="color:#66d9ef">var</span> _data :<span style="color:#f92672">=</span> {}
<span style="color:#66d9ef">var</span> _path: AStar2D <span style="color:#f92672">=</span> null
<span style="color:#66d9ef">var</span> _sleeping_rooms :<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">var</span> _mean_room_size :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>ZERO

<span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> rooms: <span style="color:#a6e22e">Node2D</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>Rooms
<span style="color:#66d9ef">onready</span> <span style="color:#66d9ef">var</span> level: <span style="color:#a6e22e">TileMap</span> <span style="color:#f92672">=</span> <span style="color:#f92672">$</span>Level


<span style="color:#66d9ef">func</span> _ready() <span style="color:#f92672">-&gt;</span> void:
    _rng<span style="color:#f92672">.</span>randomize()
    _generate()


<span style="color:#75715e"># Calld every time stabilizes (mode changes to RigidBody2D.MODE_STATIC).</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># Once all rooms have stabilized it calcualtes a playable dungeon `_path` using the MST</span>
<span style="color:#75715e"># algorithm. Based on the calculated `_path`, it populates `_data` with room and corridor tile</span>
<span style="color:#75715e"># positions.</span>
<span style="color:#75715e">#</span>
<span style="color:#75715e"># It emits the &quot;rooms_placed&quot; signal when it finishes so we can begin the tileset placement.</span>
<span style="color:#66d9ef">func</span> _on_Room_sleeping_state_changed() <span style="color:#f92672">-&gt;</span> void:
    _sleeping_rooms <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">if</span> _sleeping_rooms <span style="color:#f92672">&lt;</span> max_rooms:
        <span style="color:#66d9ef">return</span>

    <span style="color:#66d9ef">var</span> main_rooms :<span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">var</span> main_rooms_positions :<span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> room <span style="color:#f92672">in</span> rooms<span style="color:#f92672">.</span>get_children():
        <span style="color:#66d9ef">if</span> _is_main_room(room):
            main_rooms<span style="color:#f92672">.</span>push_back(room)
            main_rooms_positions<span style="color:#f92672">.</span>push_back(room<span style="color:#f92672">.</span>position)

    _path <span style="color:#f92672">=</span> Utils<span style="color:#f92672">.</span>mst(main_rooms_positions)

    <span style="color:#66d9ef">for</span> point1_id <span style="color:#f92672">in</span> _path<span style="color:#f92672">.</span>get_points():
        <span style="color:#66d9ef">for</span> point2_id <span style="color:#f92672">in</span> _path<span style="color:#f92672">.</span>get_points():
            <span style="color:#66d9ef">if</span> (
                point1_id <span style="color:#f92672">!=</span> point2_id
                <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> _path<span style="color:#f92672">.</span>are_points_connected(point1_id, point2_id)
                <span style="color:#f92672">and</span> _rng<span style="color:#f92672">.</span>randf() <span style="color:#f92672">&lt;</span> reconnection_factor
            ):
                _path<span style="color:#f92672">.</span>connect_points(point1_id, point2_id)

    <span style="color:#66d9ef">for</span> room <span style="color:#f92672">in</span> main_rooms:
        _add_room(room)
    _add_corridors()

    set_process(false)
    emit_signal(<span style="color:#e6db74">&quot;rooms_placed&quot;</span>)


<span style="color:#75715e"># This is for visual feedback. We just re-render the rooms every frame.</span>
<span style="color:#66d9ef">func</span> _process(delta: <span style="color:#a6e22e">float</span>) <span style="color:#f92672">-&gt;</span> void:
    level<span style="color:#f92672">.</span>clear()
    <span style="color:#66d9ef">for</span> room <span style="color:#f92672">in</span> rooms<span style="color:#f92672">.</span>get_children():
        <span style="color:#66d9ef">for</span> offset <span style="color:#f92672">in</span> room:
            level<span style="color:#f92672">.</span>set_cellv(offset, <span style="color:#ae81ff">0</span>)


<span style="color:#75715e"># Places the rooms and starts the physics simulation. Once the simulation is done</span>
<span style="color:#75715e"># (&quot;rooms_placed&quot; gets emitted), it continues by assigning tiles in the Level node.</span>
<span style="color:#66d9ef">func</span> _generate() <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">for</span> _i <span style="color:#f92672">in</span> range(max_rooms):
        <span style="color:#66d9ef">var</span> room :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Room</span><span style="color:#f92672">.</span>instance()
        room<span style="color:#f92672">.</span>connect(<span style="color:#e6db74">&quot;sleeping_state_changed&quot;</span>, self, <span style="color:#e6db74">&quot;_on_Room_sleeping_state_changed&quot;</span>)
        room<span style="color:#f92672">.</span>setup(_rng, level)
        rooms<span style="color:#f92672">.</span>add_child(room)

        _mean_room_size <span style="color:#f92672">+=</span> room<span style="color:#f92672">.</span>size
    _mean_room_size <span style="color:#f92672">/=</span> rooms<span style="color:#f92672">.</span>get_child_count()

    yield(self, <span style="color:#e6db74">&quot;rooms_placed&quot;</span>)

    rooms<span style="color:#f92672">.</span>queue_free()
    level<span style="color:#f92672">.</span>clear()
    <span style="color:#66d9ef">for</span> point <span style="color:#f92672">in</span> _data:
        level<span style="color:#f92672">.</span>set_cellv(point, <span style="color:#ae81ff">0</span>)


<span style="color:#75715e"># Adds room tile positions to `_data`.</span>
<span style="color:#66d9ef">func</span> _add_room(room: <span style="color:#a6e22e">Room</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">for</span> offset <span style="color:#f92672">in</span> room:
        _data[offset] <span style="color:#f92672">=</span> null


<span style="color:#75715e"># Adds both secondary room and corridor tile positions to `_data`. Secondary rooms are the ones</span>
<span style="color:#75715e"># intersecting the corridors.</span>
<span style="color:#66d9ef">func</span> _add_corridors():
    <span style="color:#66d9ef">var</span> connected :<span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">for</span> point1_id <span style="color:#f92672">in</span> _path<span style="color:#f92672">.</span>get_points():
        <span style="color:#66d9ef">for</span> point2_id <span style="color:#f92672">in</span> _path<span style="color:#f92672">.</span>get_point_connections(point1_id):
            <span style="color:#66d9ef">var</span> point1 :<span style="color:#f92672">=</span> _path<span style="color:#f92672">.</span>get_point_position(point1_id)
            <span style="color:#66d9ef">var</span> point2 :<span style="color:#f92672">=</span> _path<span style="color:#f92672">.</span>get_point_position(point2_id)
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">Vector2</span>(point1_id, point2_id) <span style="color:#f92672">in</span> connected:
                <span style="color:#66d9ef">continue</span>

            point1 <span style="color:#f92672">=</span> level<span style="color:#f92672">.</span>world_to_map(point1)
            point2 <span style="color:#f92672">=</span> level<span style="color:#f92672">.</span>world_to_map(point2)
            _add_corridor(point1<span style="color:#f92672">.</span>x, point2<span style="color:#f92672">.</span>x, point1<span style="color:#f92672">.</span>y, <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>AXIS_X)
            _add_corridor(point1<span style="color:#f92672">.</span>y, point2<span style="color:#f92672">.</span>y, point2<span style="color:#f92672">.</span>x, <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>AXIS_Y)

            connected[<span style="color:#a6e22e">Vector2</span>(point1_id, point2_id)] <span style="color:#f92672">=</span> null
            connected[<span style="color:#a6e22e">Vector2</span>(point2_id, point1_id)] <span style="color:#f92672">=</span> null


<span style="color:#75715e"># Adds a specific corridor (defined by the input parameters) to `_data`. It also adds all</span>
<span style="color:#75715e"># secondary rooms intersecting the corridor path.</span>
<span style="color:#66d9ef">func</span> _add_corridor(start: <span style="color:#a6e22e">int</span>, end: <span style="color:#a6e22e">int</span>, constant: <span style="color:#a6e22e">int</span>, axis: <span style="color:#a6e22e">int</span>) <span style="color:#f92672">-&gt;</span> void:
    <span style="color:#66d9ef">var</span> t :<span style="color:#f92672">=</span> min(start, end)
    <span style="color:#66d9ef">while</span> t <span style="color:#f92672">&lt;=</span> max(start, end):
        <span style="color:#66d9ef">var</span> point :<span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>ZERO
        match axis:
            <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>AXIS_X:
                point <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(t, constant)
            <span style="color:#a6e22e">Vector2</span><span style="color:#f92672">.</span>AXIS_Y:
                point <span style="color:#f92672">=</span> <span style="color:#a6e22e">Vector2</span>(constant, t)

        t <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">for</span> room <span style="color:#f92672">in</span> rooms<span style="color:#f92672">.</span>get_children():
            <span style="color:#66d9ef">if</span> _is_main_room(room):
                <span style="color:#66d9ef">continue</span>

            <span style="color:#66d9ef">var</span> top_left: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> level<span style="color:#f92672">.</span>world_to_map(room<span style="color:#f92672">.</span>position <span style="color:#f92672">-</span> room<span style="color:#f92672">.</span>size <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)
            <span style="color:#66d9ef">var</span> bottom_right: <span style="color:#a6e22e">Vector2</span> <span style="color:#f92672">=</span> level<span style="color:#f92672">.</span>world_to_map(room<span style="color:#f92672">.</span>position <span style="color:#f92672">+</span> room<span style="color:#f92672">.</span>size <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>)
            <span style="color:#66d9ef">if</span> (
                top_left<span style="color:#f92672">.</span>x <span style="color:#f92672">&lt;=</span> point<span style="color:#f92672">.</span>x
                <span style="color:#f92672">and</span> point<span style="color:#f92672">.</span>x <span style="color:#f92672">&lt;</span> bottom_right<span style="color:#f92672">.</span>x
                <span style="color:#f92672">and</span> top_left<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;=</span> point<span style="color:#f92672">.</span>y
                <span style="color:#f92672">and</span> point<span style="color:#f92672">.</span>y <span style="color:#f92672">&lt;</span> bottom_right<span style="color:#f92672">.</span>y
            ):
                _add_room(room)
                t <span style="color:#f92672">=</span> bottom_right[axis]
        _data[point] <span style="color:#f92672">=</span> null


<span style="color:#66d9ef">func</span> _is_main_room(room: <span style="color:#a6e22e">Room</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">bool</span>:
    <span style="color:#66d9ef">return</span> room<span style="color:#f92672">.</span>size<span style="color:#f92672">.</span>x <span style="color:#f92672">&gt;</span> _mean_room_size<span style="color:#f92672">.</span>x <span style="color:#f92672">and</span> room<span style="color:#f92672">.</span>size<span style="color:#f92672">.</span>y <span style="color:#f92672">&gt;</span> _mean_room_size<span style="color:#f92672">.</span>y
</pre>
</body>
</html>
